# vim:filetype=jproperties:ts=4
#
# Copyright (c) 2005, 2006
# Conor McDermottroe.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the author nor the names of any contributors to
#    the software may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
# OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
JAVA_MAIN_TEMPLATE =	\/*\n\
						\	Generated by {0} on {1}\n\
						\*/\n\n\
						\import java.io.BufferedReader;\n\
						\import java.io.IOException;\n\
						\import java.io.InputStreamReader;\n\
						\import java.io.Reader;\n\
						\import java.util.Locale;\n\
						\import org.xml.sax.DocumentHandler;\n\
						\import org.xml.sax.DTDHandler;\n\
						\import org.xml.sax.EntityResolver;\n\
						\import org.xml.sax.ErrorHandler;\n\
						\import org.xml.sax.HandlerBase;\n\
						\import org.xml.sax.InputSource;\n\
						\import org.xml.sax.Parser;\n\
						\import org.xml.sax.SAXException;\n\n\
						\/** An instance of the SAX 1.0 Parser interface\n\
						\	specifically made for {2}\n\
						\*/\n\
						\class {2}Parser implements Parser {\n\
						\	/** The size of the buffer for the BufferedReader */\n\
						\	private final static int INPUT_BUFFER_SIZE = {3};\n\n\
						\	/** A reference to the currently selected DocumentHandler. */\n\
						\	public DocumentHandler documentHandler;\n\
						\	/** A reference to the currently selected DTDHandler. */\n\
						\	public DTDHandler dtdHandler;\n\
						\	/** A reference to the currently selected EntityResolver. */\n\
						\	public EntityResolver entityResolver;\n\
						\	/** A reference to the currently selected ErrorHandler. */\n\
						\	public ErrorHandler errorHandler;\n\n\
						\	/** Make a new {2}Parser.\n\n\
						\		Everything uses the default handler.\n\n\
						\	*/\n\
						\	public {2}Parser() {\n\
						\		// Make the default handler\n\
						\		HandlerBase defaultHandler = new HandlerBase();\n\n\
						\		// Make everything point to the default handler\n\
						\		documentHandler = defaultHandler;\n\
						\		dtdHandler = defaultHandler;\n\
						\		entityResolver = defaultHandler;\n\
						\		errorHandler = defaultHandler;\n\
						\	}\n\n\
						\	/** The parser itself.\n\n\
						\		@param source The input to the parser.\n\
						\		@throws SAXException,IOException\n\
						\	*/\n\
						\	public void parse(InputSource source)\n\
						\	throws SAXException, IOException\n\
						\	{\n\
						\		// Buffer the input\n\
						\		BufferedReader input;\n\
						\		// We try to accept as many encodings as possible\n\
						\		String inputEncoding;\n\n\
						\		// Create a BufferedReader from the InputSource\n\
						\		Reader in = source.getCharacterStream();\n\
						\		inputEncoding = source.getEncoding();\n\
						\		if (inputEncoding == null) {\n\
						\			inputEncoding = "UTF-8";\n\
						\		}\n\
						\		if (in == null) {\n\
						\			in = new InputStreamReader(source.getByteStream(), inputEncoding);\n\
						\		}\n\
						\		input = new BufferedReader(in, INPUT_BUFFER_SIZE);\n\n\
						\		// Now input is a BufferedReader, actually perform the parse.\n\
						\		{2} parser = new {2}(input);\n\
						\		parser.setParent(this);\n\
						\		documentHandler.startDocument();\n\
						\		while (parser.next_token() != {2}.YYEOF);\n\
						\		documentHandler.endDocument();\n\
						\	}\n\n\
						\	/** Alternative form of calling the parser, shorthand for\n\
						\		<code>parse(new InputSource(systemId))</code>\n\n\
						\		@param systemId The system identifier used to access the input.\n\
						\	*/\n\
						\	public void parse(String systemId)\n\
						\	throws SAXException, IOException\n\
						\	{\n\
						\		parse(new InputSource(systemId));\n\
						\	}\n\n\
						\	/** Accessor for the document handler.\n\n\
						\		@param handler The new document handler.\n\
						\	*/\n\
						\	public void setDocumentHandler(DocumentHandler handler) {\n\
						\		documentHandler = handler;\n\
						\	}\n\n\
						\	/** Accessor for the DTD handler.\n\n\
						\		@param handler The new DTD handler.\n\
						\	*/\n\
						\	public void setDTDHandler(DTDHandler handler) {\n\
						\		dtdHandler = handler;\n\
						\	}\n\n\
						\	/** Accessor for the entity resolver.\n\n\
						\		@param resolver The new entity resolver.\n\
						\	*/\n\
						\	public void setEntityResolver(EntityResolver resolver) {\n\
						\		entityResolver = resolver;\n\
						\	}\n\n\
						\	/** Accessor for the error handler.\n\n\
						\		@param handler The new error handler.\n\
						\	*/\n\
						\	public void setErrorHandler(ErrorHandler handler) {\n\
						\		errorHandler = handler;\n\
						\	}\n\n\
						\	/** Allow an application to request a locale\n\
						\		for errors and warnings.\n\n\
						\		This will always throw an exception as\n\
						\		this class does not support localisation\n\
						\		of errors and warnings.\n\n\
						\		@param locale The new locale\n\
						\		@throws SAXException Always :-)\n\
						\	*/\n\
						\	public void setLocale(Locale locale)\n\
						\	throws SAXException\n\
						\	{\n\
						\		throw new SAXException("Unsupported locale");\n\
						\	}\n\
						\}\n\
						\ \n
JFLEX_MAIN_TEMPLATE =	\/*\n\
						\	Generated by {0} on {1}\n\
						\*/\n\
						\import java.io.Reader;\n\
						\import java.util.MissingResourceException;\n\
						\import java.util.ResourceBundle;\n\
						\import java.util.Stack;\n\
						\import java.util.regex.Matcher;\n\
						\import java.util.regex.Pattern;\n\
						\import org.xml.sax.AttributeList;\n\
						\import org.xml.sax.Parser;\n\
						\import org.xml.sax.SAXException;\n\
						\import org.xml.sax.helpers.AttributeListImpl;\n\
						\ \n\
						\%%\n\
						\%class {2}\n\
						\%int\n\
						\%unicode\n\
						\%function next_token\n\
						\%yylexthrow SAXException\n\
						\%{\n\
						\	/** A reference to the parent SAX1.0 Parser */\n\
						\	private {2}Parser parser;\n\
						\	/** A buffer to hold content until it is ready to be output */\n\
						\	private String contentBuffer;\n\
						\	/** A stack to keep track of nesting. */\n\
						\	private Stack elementStack;\n\
						\ \n\
						\	/** Provide a reference to the implementation of \n\
						\		<code>Parser</code> that is being used to report\n\
						\		SAX 1.0 events.\n\
						\	*/\n\
						\	public void setParent({2}Parser parent) {\n\
						\		parser = parent;\n\
						\	}\n\
						\ \n\
						\	/** Empty the content buffer and report it \n\
						\		to the DocumentHandler\n\
						\	*/\n\
						\	private void flushContentBuffer()\n\
						\	throws SAXException\n\
						\	{\n\
						\		// Normalise whitespace\n\
						\		contentBuffer = contentBuffer.trim();\n\
						\		if (! contentBuffer.equals("")) {\n\
						\			parser.documentHandler.characters(	\n\
						\												contentBuffer.toCharArray(),\n\
						\												 0,\n\
						\												contentBuffer.length()\n\
						\											 );\n\
						\			contentBuffer = "";\n\
						\		}\n\
						\	}\n\
						\ \n\
						\	/** Process a string containing an attribute list and \n\
						\		produce an AttributeList representing it.\n\
						\ \n\
						\		@param attlist The <code>String</code> representation\n\
						\						of the attribute list.\n\
						\		@return An <code>AttributeList</code> representing the\n\
						\				list of attributes passed in.\n\
						\	*/\n\
						\	private AttributeList processAttlist(String attlist)\n\
						\	throws SAXException\n\
						\	{\n\
						\		// Break now if the attribute list supplied is empty\n\
						\		if (attlist.trim().equals("")) {\n\
						\			return null;\n\
						\		}\n\
						\ \n\
						\		// The attribute list to return\n\
						\		AttributeListImpl ret = new AttributeListImpl();\n\
						\ \n\
						\		// Attribute list scanner\n\
						\		int state = 0;\n\
						\		String name = "";\n\
						\		String value = "";\n\
						\		for (int i = 0; i < attlist.length(); i++) {\n\
						\			char currChar = attlist.charAt(i);\n\
						\			switch (state) {\n\
						\				case 0:\n\
						\					switch (currChar) {\n\
						\						case ''' ''':\n\
						\						case '''\\t''':\n\
						\						case '''\\r''':\n\
						\						case '''\\n''':\n\
						\							// state = 0;\n\
						\							break;\n\
						\						case '''=''':\n\
						\						case '''"''':\n\
						\						case '''\\'''':\n\
						\							throw new SAXException\n\
						\							("Syntax error in attribute list");\n\
						\						default:\n\
						\							name += currChar;\n\
						\							state = 1;\n\
						\					}\n\
						\					break;\n\
						\				case 1:\n\
						\					switch (currChar) {\n\
						\						case ''' ''':\n\
						\						case '''\\t''':\n\
						\						case '''\\r''':\n\
						\						case '''\\n''':\n\
						\							state = 2;\n\
						\							break;\n\
						\						case '''=''':\n\
						\							state = 3;\n\
						\							break;\n\
						\						case '''"''':\n\
						\						case '''\\'''':\n\
						\							throw new SAXException\n\
						\							("Syntax error in attribute list");\n\
						\						default:\n\
						\							name += currChar;\n\
						\							// state = 1;\n\
						\					}\n\
						\					break;\n\
						\				case 2:\n\
						\					switch (currChar) {\n\
						\						case ''' ''':\n\
						\						case '''\\t''':\n\
						\						case '''\\r''':\n\
						\						case '''\\n''':\n\
						\							// state = 2;\n\
						\							break;\n\
						\						case '''=''':\n\
						\							state = 3;\n\
						\							break;\n\
						\						default:\n\
						\							throw new SAXException\n\
						\							("Syntax error in attribute list");\n\
						\					}\n\
						\					break;\n\
						\				case 3:\n\
						\					switch (currChar) {\n\
						\						case ''' ''':\n\
						\						case '''\\t''':\n\
						\						case '''\\r''':\n\
						\						case '''\\n''':\n\
						\							// state = 3;\n\
						\							break;\n\
						\						case '''"''':\n\
						\							state = 4;\n\
						\							break;\n\
						\						case '''\\'''':\n\
						\							state = 6;\n\
						\							break;\n\
						\						default:\n\
						\							throw new SAXException\n\
						\							("Syntax error in attribute list");\n\
						\					}\n\
						\					break;\n\
						\				case 4:\n\
						\					switch (currChar) {\n\
						\						case '''"''':\n\
						\							ret.addAttribute(name, "CDATA", value);\n\
						\							name = "";\n\
						\							value = "";\n\
						\							state = 5;\n\
						\							break;\n\
						\						default:\n\
						\							value += currChar;\n\
						\							// state = 4;\n\
						\					}\n\
						\					break;\n\
						\				case 5:\n\
						\					switch (currChar) {\n\
						\						case ''' ''':\n\
						\						case '''\\t''':\n\
						\						case '''\\r''':\n\
						\						case '''\\n''':\n\
						\							state = 0;\n\
						\							break;\n\
						\						default:\n\
						\							throw new SAXException\n\
						\							("Syntax error in attribute list");\n\
						\					}\n\
						\					break;\n\
						\				case 6:\n\
						\					switch (currChar) {\n\
						\						case '''\\'''':\n\
						\							ret.addAttribute(name, "CDATA", value);\n\
						\							name = "";\n\
						\							value = "";\n\
						\							state = 5;\n\
						\							break;\n\
						\						default:\n\
						\							value += currChar;\n\
						\							// state = 6;\n\
						\					}\n\
						\					break;\n\
						\			}\n\
						\		}\n\
						\ \n\
						\		// We''re done.\n\
						\		return ret;\n\
						\	}\n\
						\%}\n\
						\%init{\n\
						\	// Initially the content buffer is empty\n\
						\	contentBuffer = "";\n\
						\	// Create the element stack\n\
						\	elementStack = new Stack();\n\
						\%init}\n\
						\%%\n\
						\"<?"~"?>"\n\
						\	{\n\
						\		flushContentBuffer();\n\
						\		// Processing instruction\n\
						\ \n\
						\		// XML Spec section 2.6 forbids PITarget tokens\n\
						\		// that match [Xx][Mm][Ll]\n\
						\		if ((yycharat(2) == '''X''' || yycharat(2) == '''x''') &&\n\
						\			(yycharat(3) == '''M''' || yycharat(3) == '''m''') &&\n\
						\			(yycharat(4) == '''L''' || yycharat(4) == '''l'''))\n\
						\		{\n\
						\			// Probably a text or XML declaration\n\
						\			// We ignore those.\n\
						\		} {3}\
						\	}\n\
						\ \n\
						\{4}\n\
						\{5}\n\
						\{6}\n\
						\"<"[^>]*"/>"\n\
						\	{\n\
						\		// Empty element\n\
						\		flushContentBuffer();\n\
						\		String tag = yytext().substring(1, yylength() - 2).trim();\n\
						\		{7}\n\
						\	}\n\
						\ \n\
						\"</"[^>]*">"\n\
						\	{\n\
						\		// End tag\n\
						\		flushContentBuffer();\n\
						\		String tag = yytext().substring(2, yylength() - 1).trim();\n\
						\		String topOfStack = (String)elementStack.peek();\n\
						\		if (elementStack.empty() || ! (topOfStack.equals(tag))) {\n\
						\			throw new SAXException("Well formedness error: </" + tag + "> where </" + topOfStack + "> expected");\n\
						\		} else {\n\
						\			elementStack.pop();\n\
						\		}\n\
						\		parser.documentHandler.endElement(yytext().substring(2, yylength() - 1).trim());\n\
						\	}\n\
						\ \n\
						\"<"[^>]*">"\n\
						\	{\n\
						\		// Start tag\n\
						\		flushContentBuffer();\n\
						\		String tag = yytext().substring(1, yylength() - 1).trim();\n\
						\		{8}\n\
						\	}\n\
						\ \n\
						\{9}\n\
						\{10}\n\
						\{11}\n\
						\{12}\n\
						\ \n\
						\[^&<]+\n\
						\	{\n\
						\		// Catch all, treat as content\n\
						\		contentBuffer += yytext();\n\
						\	}\n\
						\ \n\
						\[\\u0000-\\uFFFF]\n\
						\	{\n\
						\		// Really catch all\n\
						\		contentBuffer += yytext();\n\
						\	}\n
PROCESSING_INSTRUCTION_PROCESSOR = \else {\n\
						\			// Get the PI and strip off the <? and ?>\n\
						\			String pi = yytext().substring(2, yylength() - 2).trim();\n\
						\ \n\
						\			// Find the index of the first whitespace character\n\
						\			int fWI = -1;\n\
						\			for (int i = 0; i < pi.length(); i++) {\n\
						\				if (Character.isWhitespace(pi.charAt(i))) {\n\
						\					fWI = i;\n\
						\					break;\n\
						\				}\n\
						\			}\n\
						\ \n\
						\			// Get the target and data\n\
						\			String target = null;\n\
						\			String data = null;\n\
						\			if (fWI >= 0) {\n\
						\				// Looks like there's a target AND data\n\
						\				target = pi.substring(0, fWI);\n\
						\				data = pi.substring(fWI);\n\
						\			} else {\n\
						\				// Target only by the looks of things.\n\
						\				target = pi;\n\
						\			}\n\
						\			parser.documentHandler.processingInstruction(target, data);\n\
						\		}\n
COMMENT_PROCESSOR = 	\"<!--"~"-->"\n\
						\	{\n\
						\		// Comment, ignore.\n\
						\	}\n
DOCTYPEDECL_PROCESSOR = \"<!DOCTYPE"~">"\n\
						\	{\n\
						\		// Document type declaration and internal subset, ignore.\n\
						\	}\n
CDSECT_PROCESSOR =		\"<![CDATA["~"]]>"\n\
						\	{\n\
						\		// CData section, everything goes into the content buffer\n\
						\		contentBuffer += yytext().substring(9, yylength() - 3);\n\
						\	}\n
START_TAG_ATTLIST =		\String elementName;\n\
						\		AttributeList attlist = null;\n\
						\		\n\
						\		// Find the first whitespace character\n\
						\		int fWI = -1;\n\
						\		for (int i = 0; i < tag.length(); i++) {\n\
						\			if (Character.isWhitespace(tag.charAt(i))) {\n\
						\				fWI = i;\n\
						\				break;\n\
						\			}\n\
						\		}\n\
						\		\n\
						\		// Detect whether or not there's an attribute list\n\
						\		// and strip out the element name\n\
						\		if (fWI >= 0) {\n\
						\			elementName = tag.substring(0, fWI);\n\
						\			\n\
						\			// Process the attribute list\n\
						\			String atts = tag.substring(fWI);\n\
						\			attlist = processAttlist(atts);\n\
						\		} else {\n\
						\			elementName = tag;\n\
						\		}\n\
						\		\n\
						\		parser.documentHandler.startElement(elementName, attlist);\n\
						\		elementStack.push(elementName);\n
EMPTY_TAG_ATTLIST =		\String elementName;\n\
						\		AttributeList attlist = null;\n\
						\		\n\
						\		// Find the first whitespace character\n\
						\		int fWI = -1;\n\
						\		for (int i = 0; i < tag.length(); i++) {\n\
						\			if (Character.isWhitespace(tag.charAt(i))) {\n\
						\				fWI = i;\n\
						\				break;\n\
						\			}\n\
						\		}\n\
						\		\n\
						\		// Detect whether or not there's an attribute list\n\
						\		// and strip out the element name\n\
						\		if (fWI >= 0) {\n\
						\			elementName = tag.substring(0, fWI);\n\
						\			\n\
						\			// Process the attribute list\n\
						\			String atts = tag.substring(fWI);\n\
						\			attlist = processAttlist(atts);\n\
						\		} else {\n\
						\			elementName = tag;\n\
						\		}\n\
						\		\n\
						\		parser.documentHandler.startElement(elementName, attlist);\n\
						\		parser.documentHandler.endElement(elementName);\n
START_TAG_NO_ATTLIST =	\		parser.documentHandler.startElement(tag, null);\n\
						\		elementStack.push(tag);\n
EMPTY_TAG_NO_ATTLIST =	\		parser.documentHandler.startElement(tag, null);\n\
						\		parser.documentHandler.endElement(tag);\n
PREDEFINED_ENTITIES =	\// Predefined entities\n\
						\"&amp;" { contentBuffer += "&"; }\n\
						\"&lt;" { contentBuffer += "<"; }\n\
						\"&gt;" { contentBuffer += ">"; }\n\
						\"&apos;" { contentBuffer += "'"; }\n\
						\"&quot;" { contentBuffer += "\\""; }\n\
						\ \n
CHAR_REF_RESOLVER =		\"&#"[^;]+";"\n\
						\	{ \n\
						\		// Character reference, resolve and add to the content buffer.\n\
						\		String ref = yytext().substring(2, yylength() - 1);\n\
						\		if (ref.startsWith("x")) {\n\
						\			ref = ref.substring(1);\n\
						\			contentBuffer += (char)Integer.parseInt(ref, 16);\n\
						\		} else {\n\
						\			contentBuffer += (char)Integer.parseInt(ref, 10);\n\
						\		}\n\
						\	}\n\
						\ \n
INTERNAL_ENT_RESOLVER =	\"&"~";"\n\
						\	{\n\
						\		// Internal Entity Reference\n\
						\		try {\n\
						\			contentBuffer += ResourceBundle.getBundle("entities").getString(yytext());\n\
						\		} catch (MissingResourceException e) {\n\
						\			// Undefined internal entity\n\
						\			// Just add it to the content buffer\n\
						\			contentBuffer += yytext();\n\
						\		}\n\
						\	}\n
INT_ENT_PROP_TEXT_FMT =	\	&{0}; = {1}\n
EXT_ENT_PROP_TEXT_FMT = \	"&{0};"\n\
						\		{\n\
						\			// External parsed entity\n\
						\			InputSource entityIn = parser.entityResolver.resolveEntity({1}, {2});\n\
						\			Reader in = entityIn.getCharacterStream();\n\
						\			if (in == null) {\n\
						\				in = new InputStreamReader(entityIn.getByteStream(), entityIn.getEncoding());\n\
						\			}\n\
						\			yypushstream(in);\n\
						\		}\n\n
BUILD_MAIN_TEMPLATE =	\<?xml version="1.0"?>\n\
						\<!--\n\
						\	Generated by {0} on {1}\n\
						\-->\n\
						\ \n\
						\<project name="{2}" default="jar" basedir=".">\n\
						\	<taskdef name="jflex" classname="JFlex.anttask.JFlexTask" />\n\
						\ \n\
						\	<target name="build" depends="runjflex">\n\
						\		<javac srcdir="." />\n\
						\	</target>\n\
						\	<target name="runjflex">\n\
						\		<jflex file="{2}.jflex" />\n\
						\	</target>\n\
						\	<target name="jar" depends="build">\n\
						\		<jar destfile="{2}.jar" basedir="." includes="*.class,*.properties" />\n\
						\	</target>\n\
						\	<target name="clean">\n\
						\		<delete file="{2}.java" />\n\
						\		<delete>\n\
						\			<fileset dir="." includes="*.class,*.jar" />\n\
						\		</delete>\n\
						\	</target>\n\
						\</project>\n
ENTITIES_MAIN_TEMPLATE =\# Generated by {0} on {1}\n\
						\{2}
