# vim:filetype=jproperties:ts=4
#
# Copyright (c) 2007, 2008
# Conor McDermottroe.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the author nor the names of any contributors to
#    the software may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
# OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
ABSTRACT_ELEMENT_CLASS	=	\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\import java.io.IOException;\n\
							\import java.io.Writer;\n\
							\import java.util.Iterator;\n\
							\import java.util.List;\n\
							\import java.util.Map;\n\
							\import java.util.SortedMap;\n\
							\import java.util.SortedSet;\n\
							\import java.util.TreeMap;\n\
							\import java.util.TreeSet;\n\
							\n\
							\/** The base class of all element classes.\n\
							\n\
							\	@author		{0}\n\
							\	@since		{1}\n\
							\	@param	<T>	The type of {@link {0}Element} this is.\n\
							\*/\n\
							\public abstract class {0}Element<T extends {0}Element<T>>\n\
							\extends XMLComponent<T>\n\
							\{\n\
							\	/** The attributes, if any. */\n\
							\	protected final SortedMap<String, {0}Attribute> attributes;\n\
							\n\
							\	/** The name of the element. */\n\
							\	protected final String name;\n\
							\n\
							\	/** Create a new anonymous {0}Element. */\n\
							\	protected {0}Element() {\n\
							\		this(null);\n\
							\	}\n\
							\n\
							\	/** Create a new {0}Element.\n\
							\n\
							\		@param	elementName	The name of the element.\n\
							\	*/\n\
							\	protected {0}Element(String elementName) {\n\
							\		super();\n\
							\		name = elementName;\n\
							\		attributes = new TreeMap<String, {0}Attribute>();\n\
							\	}\n\
							\n\
							\	/** Get the name of this element.\n\
							\n\
							\		@return	The name of this element.\n\
							\	*/\n\
							\	public String name() {\n\
							\		return name;\n\
							\	}\n\
							\n\
							\	/** Get the attributes of this element.\n\
							\n\
							\		@return	The attributes of this element.\n\
							\	*/\n\
							\	public Map<String, {0}Attribute> attributes() {\n\
							\		return new TreeMap<String, {0}Attribute>(attributes);\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	@Override public void add(XMLComponent<?> child) {\n\
							\		super.add(child);\n\
							\		if (children.size() >= 2) {\n\
							\			int last = children.size() - 1;\n\
							\			if	(\n\
							\					XMLContent.class.isAssignableFrom(\n\
							\						children.get(last).getClass()\n\
							\					) &&\n\
							\					XMLContent.class.isAssignableFrom(\n\
							\						children.get(last - 1).getClass()\n\
							\					)\n\
							\				)\n\
							\			{\n\
							\					XMLContent.class.cast(children.get(last - 1)).append(\n\
							\					XMLContent.class.cast(children.get(last))\n\
							\				);\n\
							\				children.remove(last);\n\
							\			}\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	@Override public void write(Writer w, int depth)\n\
							\	throws IOException\n\
							\	{\n\
							\		for (int i = 0; i < depth; i++) {\n\
							\			w.write("    ");\n\
							\		}\n\
							\		w.write("<");\n\
							\		w.write(name);\n\
							\		if (!attributes.isEmpty()) {\n\
							\			for ({0}Attribute att : attributes.values()) {\n\
							\				att.write(w, depth);\n\
							\			}\n\
							\		}\n\
							\		if (children.isEmpty()) {\n\
							\			w.write(" />");\n\
							\		} else {\n\
							\			w.write(">");\n\
							\			Class<XMLContent> xmlContentClass = XMLContent.class;\n\
							\			if	(\n\
							\					children.size() == 1 &&\n\
							\					xmlContentClass.isAssignableFrom(\n\
							\						children.get(0).getClass()\n\
							\					)\n\
							\				)\n\
							\			{\n\
							\				w.write(xmlContentClass.cast(children.get(0)).getContent());\n\
							\			} else {\n\
							\				w.write(EOL);\n\
							\				for (XMLComponent<?> x : children) {\n\
							\					x.write(w, depth + 1);\n\
							\				}\n\
							\				for (int i = 0; i < depth; i++) {\n\
							\					w.write("    ");\n\
							\				}\n\
							\			}\n\
							\			w.write("</");\n\
							\			w.write(name);\n\
							\				w.write(">");\n\
							\		}\n\
							\		w.write(EOL);\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	public int compareTo(XMLComponent<?> other) {\n\
							\		if (!(other instanceof {0}Element)) {\n\
							\			return getClass().getName().compareTo(\n\
							\				other.getClass().getName()\n\
							\			);\n\
							\		}\n\
							\n\
							\		{0}Element<?> otherElement = {0}Element.class.cast(other);\n\
							\		String otherName = otherElement.name();\n\
							\		if (name != null && otherName != null) {\n\
							\			int nameCmp = name.compareTo(otherElement.name());\n\
							\			if (nameCmp != 0) {\n\
							\				return nameCmp;\n\
							\			}\n\
							\		} else if (name != null) {\n\
							\			return 1;\n\
							\		} else if (otherName != null) {\n\
							\			return -1;\n\
							\		}\n\
							\n\
							\		SortedSet<{0}Attribute> thisAtts =\n\
							\			new TreeSet<{0}Attribute>();\n\
							\		thisAtts.addAll(attributes.values());\n\
							\		SortedSet<{0}Attribute> otherAtts =\n\
							\			new TreeSet<{0}Attribute>();\n\
							\		otherAtts.addAll(otherElement.attributes().values());\n\
							\		Iterator<{0}Attribute> thisAttIter = thisAtts.iterator();\n\
							\		Iterator<{0}Attribute> otherAttIter = otherAtts.iterator();\n\
							\		while (thisAttIter.hasNext() && otherAttIter.hasNext()) {\n\
							\			{0}Attribute thisAtt = thisAttIter.next();\n\
							\			{0}Attribute otherAtt = otherAttIter.next();\n\
							\			int attCmp = thisAtt.compareTo(otherAtt);\n\
							\			if (attCmp != 0) {\n\
							\				return attCmp;\n\
							\			}\n\
							\		}\n\
							\		if (thisAttIter.hasNext()) {\n\
							\			return 1;\n\
							\		}\n\
							\		if (otherAttIter.hasNext()) {\n\
							\			return -1;\n\
							\		}\n\
							\n\
							\		List<XMLComponent<?>> thisChildren = getChildren();\n\
							\		List<XMLComponent<?>> otherChildren = otherElement.getChildren();\n\
							\		Iterator<XMLComponent<?>> thisChildIter = thisChildren.iterator();\n\
							\		Iterator<XMLComponent<?>> otherChildIter = otherChildren.iterator();\n\
							\		while (thisChildIter.hasNext() && otherChildIter.hasNext()) {\n\
							\			XMLComponent<?> thisChild = thisChildIter.next();\n\
							\			XMLComponent<?> otherChild = otherChildIter.next();\n\
							\			int childCmp = thisChild.compareTo(otherChild);\n\
							\			if (childCmp != 0) {\n\
							\				return childCmp;\n\
							\			}\n\
							\		}\n\
							\		if (thisChildIter.hasNext()) {\n\
							\			return 1;\n\
							\		}\n\
							\		if (otherChildIter.hasNext()) {\n\
							\			return -1;\n\
							\		}\n\
							\n\
							\		return 0;\n\
							\	}\n\
							\}\n
ATTRIBUTE_CLASS	=			\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\import java.io.IOException;\n\
							\import java.io.Writer;\n\
							\n\
							\/** An attribute for {@link {0}Element}s.\n\
							\n\
							\	@author	{0}\n\
							\	@since	{1}\n\
							\*/\n\
							\public class {0}Attribute\n\
							\extends XMLComponent<{0}Attribute>\n\
							\{\n\
							\	/** An attribute which is not FIXED, IMPLIED or REQUIRED. */\n\
							\	public static final int DEFAULT = 0;\n\
							\n\
							\	/** An attribute which is FIXED. */\n\
							\	public static final int FIXED = 1;\n\
							\n\
							\	/** An attribute which is IMPLIED. */\n\
							\	public static final int IMPLIED = 2;\n\
							\n\
							\	/** An attribute which is REQUIRED. */\n\
							\	public static final int REQUIRED = 3;\n\
							\n\
							\	/** The attribute's default value if any. */\n\
							\	private final String defaultValue;\n\
							\n\
							\	/** The name of the attribute. */\n\
							\	private final String attName;\n\
							\n\
							\	/** The type of the attribute. */\n\
							\	private final int type;\n\
							\n\
							\	/** The attribute's current value, if any. */\n\
							\	private String value = null;\n\
							\n\
							\	/** This is set if the attribute has been given a value. */\n\
							\	private boolean isSet;\n\
							\n\
							\	/** Create a new Attribute.\n\
							\n\
							\		@param	name		The name of the attribute.\n\
							\		@param	attType		The type of the attribute.\n\
							\		@param	defValue	The default value for the attribute, if appropriate.\n\
							\	*/\n\
							\	public {0}Attribute(String name, int attType, String defValue) {\n\
							\		super();\n\
							\		attName = name;\n\
							\		type = attType;\n\
							\		if (attType == DEFAULT || attType == FIXED) {\n\
							\			if (defValue != null) {\n\
							\				defaultValue = defValue;\n\
							\				value = defValue;\n\
							\			} else {\n\
							\				throw new IllegalArgumentException(\n\
							\					"The default value of an attribute may not be null"\n\
							\				);\n\
							\			}\n\
							\		} else {\n\
							\			if (defValue != null) {\n\
							\				throw new IllegalArgumentException(\n\
							\					"Illegal default value for REQUIRED or IMPLIED attribute."\n\
							\				);\n\
							\			}\n\
							\			defaultValue = null;\n\
							\		}\n\
							\		isSet = false;\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	public int compareTo(XMLComponent<?> other) {\n\
							\		if (!(other instanceof {0}Attribute)) {\n\
							\			return getClass().getName().compareTo(\n\
							\				other.getClass().getName()\n\
							\			);\n\
							\		}\n\
							\n\
							\		{0}Attribute otherAtt = getClass().cast(other);\n\
							\n\
							\		int nameCmp = attName.compareTo(otherAtt.getName());\n\
							\		if (nameCmp != 0) {\n\
							\			return nameCmp;\n\
							\		}\n\
							\n\
							\		String otherValue = otherAtt.getValue();\n\
							\		if (value != null && otherValue != null) {\n\
							\			int valueCmp = value.compareTo(otherValue);\n\
							\			if (valueCmp != 0) {\n\
							\				return valueCmp;\n\
							\			}\n\
							\		} else if (value != null) {\n\
							\			return 1;\n\
							\		} else if (otherValue != null) {\n\
							\			return -1;\n\
							\		} else {\n\
							\			return 0;\n\
							\		}\n\
							\n\
							\		int typeCmp = type - otherAtt.getType();\n\
							\		if (typeCmp != 0) {\n\
							\			return typeCmp;\n\
							\		}\n\
							\n\
							\		if (type == REQUIRED || type == IMPLIED) {\n\
							\			return 0;\n\
							\		}\n\
							\n\
							\		String otherDefault = otherAtt.getDefaultValue();\n\
							\		if (defaultValue != null && otherDefault != null) {\n\
							\			return defaultValue.compareTo(otherDefault);\n\
							\		} else if (defaultValue != null) {\n\
							\			return 1;\n\
							\		} else if (otherDefault != null) {\n\
							\			return -1;\n\
							\		} else {\n\
							\			return 0;\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** Get the default value of the attribute.\n\
							\n\
							\		@return	The default value of the attribute.\n\
							\	*/\n\
							\	public String getDefaultValue() {\n\
							\		if (defaultValue != null) {\n\
							\			return defaultValue;\n\
							\		} else {\n\
							\			throw new UnsupportedOperationException(\n\
							\				attName + " attributes do not have a default."\n\
							\			);\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** Get the name of the attribute.\n\
							\n\
							\		@return	The name of the attribute.\n\
							\	*/\n\
							\	public String getName() {\n\
							\		return attName;\n\
							\	}\n\
							\n\
							\	/** Get the type of the attribute.\n\
							\n\
							\		@return	The type of the attribute.\n\
							\	*/\n\
							\	public int getType() {\n\
							\		return type;\n\
							\	}\n\
							\n\
							\	/** Get the value of the attribute.\n\
							\n\
							\		@return	The value of the attribute.\n\
							\	*/\n\
							\	public String getValue() {\n\
							\		return value;\n\
							\	}\n\
							\n\
							\	/** Set the value of the attribute.\n\
							\n\
							\		@param	val	The value for the attribute.\n\
							\	*/\n\
							\	public void setValue(String val) {\n\
							\		if (type == FIXED) {\n\
							\			throw new UnsupportedOperationException(\n\
							\				"Cannot set value, " + attName + " is a FIXED attribute"\n\
							\			);\n\
							\		}\n\
							\		value = val;\n\
							\		isSet = val != null;\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	@Override public void write(Writer w, int depth)\n\
							\	throws IOException\n\
							\	{\n\
							\		if (isSet) {\n\
							\			w.write(" ");\n\
							\			w.write(attName);\n\
							\			w.write("=\\"");\n\
							\			w.write(value);\n\
							\			w.write("\\"");\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** Override {@link Object#hashCode()}.\n\
							\n\
							\		@return	A hashcode for this object.\n\
							\	*/\n\
							\	@Override public int hashCode() {\n\
							\		int hashCode = 0;\n\
							\n\
							\		if (attName != null) {\n\
							\			hashCode += attName.hashCode();\n\
							\		}\n\
							\		hashCode *= HASHCODE_MAGIC;\n\
							\		if (value != null) {\n\
							\			hashCode += value.hashCode();\n\
							\		}\n\
							\		hashCode *= HASHCODE_MAGIC;\n\
							\		hashCode += type;\n\
							\		hashCode *= HASHCODE_MAGIC;\n\
							\		if (defaultValue != null) {\n\
							\			hashCode += defaultValue.hashCode();\n\
							\		}\n\
							\		hashCode *= HASHCODE_MAGIC;\n\
							\n\
							\		return hashCode;\n\
							\	}\n\
							\n\
							\	/** Override {@link Object#equals(Object)}.\n\
							\n\
							\		@param	o	The {@link Object} to test equality against.\n\
							\		@return		True if this is equal to <code>o</code>, false otherwise.\n\
							\	*/\n\
							\	@Override public boolean equals(Object o) {\n\
							\		if (this == o) {\n\
							\			return true;\n\
							\		}\n\
							\		if (o == null) {\n\
							\			return false;\n\
							\		}\n\
							\		if (!(o instanceof {0}Attribute)) {\n\
							\			return false;\n\
							\		}\n\
							\n\
							\		return compareTo({0}Attribute.class.cast(o)) == 0;\n\
							\	}\n\
							\}\n
ELEMENT_CLASS	=			\/* Generated by {0} on {1}. */\n\
							\package {2}.element;\n\
							\n\
							\{9}import {2}.support.{0}Element;\n\
							\n\
							\/** A class for representing {3} elements.\n\
							\n\
							\	@author	{0}\n\
							\	@since	{1}\n\
							\*/\n\
							\public class {4}\n\
							\extends {0}Element<{4}>\n\
							\{\n\
							\	/** Create a {3} element object. */\n\
							\	public {4}() {\n\
							\		super("{3}");\n\
							\		assert attributes != null;\n\
							\{5}\n\
							\	}\n\
							\{6}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	@Override public boolean equals(Object o) {\n\
							\		if (this == o) {\n\
							\			return true;\n\
							\		}\n\
							\		if (o == null) {\n\
							\			return false;\n\
							\		}\n\
							\		if (!{4}.class.isAssignableFrom(o.getClass())) {\n\
							\			return false;\n\
							\		}\n\
							\n\
							\		return {4}.class.cast(o).compareTo(this) == 0;\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	@Override public int hashCode() {\n\
							\		int code = 0;\n\
							\		if (name != null) {\n\
							\			code += name.hashCode();\n\
							\		}\n\
							\		code *= HASHCODE_MAGIC;\n\
							\{8}\n\
							\		return code;\n\
							\	}\n\
							\}\n
PI_CLASS	=				\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\import java.io.IOException;\n\
							\import java.io.Writer;\n\
							\n\
							\/** An XML processing instruction.\n\
							\n\
							\	@author	{0}\n\
							\	@since	{1}\n\
							\*/\n\
							\public class ProcessingInstruction\n\
							\extends XMLComponent<ProcessingInstruction>\n\
							\{\n\
							\	/** The target portion of the processing instruction. */\n\
							\	private final String piTarget;\n\
							\n\
							\	/** The data portion of the processing instruction. */\n\
							\	private final String piData;\n\
							\n\
							\	/** Create a new processing instruction.\n\
							\n\
							\		@param	target	The target portion of the processing instruction.\n\
							\		@param	data	The data portion of the processing instruction.\n\
							\	*/\n\
							\	public ProcessingInstruction(String target, String data) {\n\
							\		super();\n\
							\		piTarget = target;\n\
							\		piData = data;\n\
							\	}\n\
							\n\
							\	/** Get the target portion of the processing instruction.\n\
							\n\
							\		@return	The target portion of the processing instruction.\n\
							\	*/\n\
							\	public String getTarget() {\n\
							\		return piTarget;\n\
							\	}\n\
							\n\
							\	/** Get the data portion of the processing instruction.\n\
							\n\
							\		@return	The data portion of the processing instruction.\n\
							\	*/\n\
							\	public String getData() {\n\
							\		return piData;\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	@Override public void write(Writer w, int depth)\n\
							\	throws IOException\n\
							\	{\n\
							\		for (int i = 0; i < depth; i++) {\n\
							\			w.write("    ");\n\
							\		}\n\
							\		w.write("<?");\n\
							\		w.write(piTarget);\n\
							\		w.write(" ");\n\
							\		w.write(piData);\n\
							\		w.write("?>");\n\
							\		w.write(EOL);\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	public int compareTo(XMLComponent<?> other) {\n\
							\		ProcessingInstruction pi = ProcessingInstruction.class.cast(other);\n\
							\		int targetCmp = piTarget.compareTo(pi.getTarget());\n\
							\		if (targetCmp != 0) {\n\
							\			return targetCmp;\n\
							\		}\n\
							\		return piData.compareTo(pi.getData());\n\
							\	}\n\
							\}\n
ROOT_PARSER_CLASS	=		\/* Generated by {0} on {1}. */\n\
							\package {2};\n\
							\n\
							\import java.io.BufferedReader;\n\
							\import java.io.BufferedWriter;\n\
							\import java.io.File;\n\
							\import java.io.FileReader;\n\
							\import java.io.FileWriter;\n\
							\import java.io.IOException;\n\
							\import java.io.InputStream;\n\
							\import java.io.InputStreamReader;\n\
							\import java.io.OutputStream;\n\
							\import java.io.OutputStreamWriter;\n\
							\import java.io.Writer;\n\
							\import java.lang.reflect.InvocationTargetException;\n\
							\import java.lang.reflect.Method;\n\
							\import java.util.Collection;\n\
							\import java.util.Iterator;\n\
							\import java.util.Stack;\n\
							\n\
							\import org.xml.sax.Attributes;\n\
							\import org.xml.sax.ErrorHandler;\n\
							\import org.xml.sax.InputSource;\n\
							\import org.xml.sax.Locator;\n\
							\import org.xml.sax.SAXException;\n\
							\import org.xml.sax.SAXParseException;\n\
							\import org.xml.sax.XMLReader;\n\
							\import org.xml.sax.helpers.DefaultHandler;\n\
							\import org.xml.sax.helpers.XMLReaderFactory;\n\
							\n\
							\import {2}.support.ProcessingInstruction;\n\
							\import {2}.support.{4};\n\
							\import {2}.support.{5};\n\
							\import {2}.support.XMLComponent;\n\
							\import {2}.support.XMLContent;\n\
							\n\
							\/** A parser for {3} documents.\n\
							\n\
							\	@author	{0}\n\
							\	@since	{1}\n\
							\*/\n\
							\public final class {3} {\n\
							\	/** This class is a utility class solely consisting of static methods,\n\
							\		it should not be instantiated.\n\
							\	*/\n\
							\	private {3}() {\n\
							\	}\n\
							\n\
							\	/** Read the document from a {@link BufferedReader}.\n\
							\n\
							\		@param	reader			A {@link BufferedReader} to read the XML\n\
							\								document from.\n\
							\		@return					An {@link XMLComponent} representing the\n\
							\								document.\n\
							\		@throws IOException		If the input stream throws an error.\n\
							\		@throws SAXException	if the underlying SAX parser throws one.\n\
							\	*/\n\
							\	private static XMLComponent<?> read(BufferedReader reader)\n\
							\	throws IOException, SAXException\n\
							\	{\n\
							\		XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n\
							\		xmlReader.setErrorHandler(\n\
							\			new ErrorHandler() {\n\
							\				public void error(SAXParseException exception)\n\
							\				throws SAXException\n\
							\				{\n\
							\					throw new SAXException(exception);\n\
							\				}\n\
							\n\
							\				public void fatalError(SAXParseException exception)\n\
							\				throws SAXException\n\
							\				{\n\
							\					throw new SAXException(exception);\n\
							\				}\n\
							\n\
							\				public void warning(SAXParseException exception)\n\
							\				throws SAXException\n\
							\				{\n\
							\					throw new SAXException(exception);\n\
							\				}\n\
							\			}\n\
							\		);\n\
							\		{3}ContentHandler contentHandler = new {3}ContentHandler();\n\
							\		xmlReader.setContentHandler(contentHandler);\n\
							\		xmlReader.parse(new InputSource(reader));\n\
							\		return contentHandler.getRootElement();\n\
							\	}\n\
							\n\
							\	/** Read the document from an {@link InputStream}.\n\
							\n\
							\		@param	input			An {@link InputStream} to read the XML document\n\
							\								from.\n\
							\		@return					An {@link XMLComponent} representing the\n\
							\								document.\n\
							\		@throws IOException		If the input stream throws an error.\n\
							\		@throws SAXException	if the underlying SAX parser throws one.\n\
							\	*/\n\
							\	public static XMLComponent<?> read(InputStream input)\n\
							\	throws IOException, SAXException\n\
							\	{\n\
							\		BufferedReader br = null;\n\
							\		try {\n\
							\			br = new BufferedReader(new InputStreamReader(input));\n\
							\			return read(br);\n\
							\		} finally {\n\
							\			try {\n\
							\				if (br != null) {\n\
							\					br.close();\n\
							\				}\n\
							\			} catch (IOException e) {\n\
							\				// Ignore, this is a best-effort close.\n\
							\				assert e != null;\n\
							\			}\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** Read the document from a {@link File}.\n\
							\n\
							\		@param	file					A {@link File} to read the XML document\n\
							\										from.\n\
							\		@return							An {@link XMLComponent} representing the\n\
							\										document.\n\
							\		@throws IOException				If the input stream throws an error.\n\
							\		@throws SAXException			If the underlying SAX parser throws one.\n\
							\	*/\n\
							\	public static XMLComponent<?> read(File file)\n\
							\	throws IOException, SAXException\n\
							\	{\n\
							\		BufferedReader br = null;\n\
							\		try {\n\
							\			br = new BufferedReader(new FileReader(file));\n\
							\			return read(br);\n\
							\		} finally {\n\
							\			try {\n\
							\				if (br != null) {\n\
							\					br.close();\n\
							\				}\n\
							\			} catch (IOException e) {\n\
							\				// Ignore, this is a best-effort close.\n\
							\				assert e != null;\n\
							\			}\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** Write a document from a root element to a {@link BufferedWriter}.\n\
							\n\
							\		@param	rootElement	The root element of the document.\n\
							\		@param	bw			The {@link BufferedWriter} to write it to.\n\
							\		@throws	IOException	If the data fails to write.\n\
							\	*/\n\
							\	private static void write(XMLComponent<?> rootElement, BufferedWriter bw)\n\
							\	throws IOException\n\
							\	{\n\
							\		if (rootElement == null || bw == null) {\n\
							\			return;\n\
							\		}\n\
							\		bw.write("<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" ?>\\n");\n\
							\		rootElement.write(bw);\n\
							\		bw.flush();\n\
							\	}\n\
							\n\
							\	/** Write a document from a root element to an {@link OutputStream}.\n\
							\n\
							\		@param	rootElement	The root element of the document.\n\
							\		@param	output		The {@link OutputStream} to write it to.\n\
							\		@throws	IOException	If the data fails to write.\n\
							\	*/\n\
							\	public static void write(XMLComponent<?> rootElement, OutputStream output)\n\
							\	throws IOException\n\
							\	{\n\
							\		if (rootElement == null || output == null) {\n\
							\			return;\n\
							\		}\n\
							\		BufferedWriter bw = null;\n\
							\		try {\n\
							\			bw = new BufferedWriter(new OutputStreamWriter(output));\n\
							\			write(rootElement, bw);\n\
							\		} finally {\n\
							\			try {\n\
							\				if (bw != null) {\n\
							\					bw.close();\n\
							\				}\n\
							\			} catch (IOException e) {\n\
							\				// Ignore, this is a best-effort close.\n\
							\				assert e != null;\n\
							\			}\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** Write a document from a root element to a {@link File}.\n\
							\n\
							\		@param	rootElement	The root element of the document.\n\
							\		@param	file		The {@link File} to write it to.\n\
							\		@throws	IOException	If the data fails to write.\n\
							\	*/\n\
							\	public static void write(XMLComponent<?> rootElement, File file)\n\
							\	throws IOException\n\
							\	{\n\
							\		if (rootElement == null || file == null) {\n\
							\			return;\n\
							\		}\n\
							\		BufferedWriter bw = null;\n\
							\		try {\n\
							\			bw = new BufferedWriter(new FileWriter(file));\n\
							\			write(rootElement, bw);\n\
							\		} finally {\n\
							\			try {\n\
							\				if (bw != null) {\n\
							\					bw.close();\n\
							\				}\n\
							\			} catch (IOException e) {\n\
							\				// Ignore, this is a best-effort close.\n\
							\				assert e != null;\n\
							\			}\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** Walk a tree of {@link XMLComponent}s applying {@link {5}}s\n\
							\		to each node.\n\
							\n\
							\		@param	element			The {@link XMLComponent} to start from.\n\
							\		@param	ops				The {@link {5}}s to apply to each\n\
							\								node.\n\
							\		@throws	{4}	if any of the operations fail.\n\
							\	*/\n\
							\	public static void walk(\n\
							\		XMLComponent<?> element,\n\
							\		Collection<{5}> ops\n\
							\	)\n\
							\	throws {4}\n\
							\	{\n\
							\		if (element == null || ops == null) {\n\
							\			return;\n\
							\		}\n\
							\		for ({5} op : ops) {\n\
							\			if (op.shouldApply(element)) {\n\
							\				op.execute(element);\n\
							\			}\n\
							\		}\n\
							\		for (XMLComponent<?> child : element.getChildren()) {\n\
							\			walk(child, ops);\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** The SAX ContentHandler to use to parse the input.\n\
							\n\
							\		@author {0}\n\
							\		@since	{1}\n\
							\	*/\n\
							\	private static final class {3}ContentHandler\n\
							\	extends DefaultHandler\n\
							\	{\n\
							\		/** The {@link XMLComponent} currently being processed. */\n\
							\		private XMLComponent<?> currentElement;\n\
							\n\
							\		/** A stack of {@link XMLComponent}s representing the path to the\n\
							\			current element in the tree.\n\
							\		*/\n\
							\		private Stack<XMLComponent<?>> elementStack;\n\
							\n\
							\		/** A {@link Locator} which can be used to report the location of\n\
							\			errors in the source file.\n\
							\		*/\n\
							\		private Locator locator;\n\
							\n\
							\		/** Create a new {@link {3}ContentHandler}. */\n\
							\		private {3}ContentHandler() {\n\
							\			super();\n\
							\			currentElement = new DocumentRootElement();\n\
							\			elementStack = new Stack<XMLComponent<?>>();\n\
							\			locator = null;\n\
							\		}\n\
							\n\
							\		/** Get the root element of the parsed document. This will only return a\n\
							\			sensible result after parsing has successfully completed.\n\
							\n\
							\			@return	The root element of the parsed document.\n\
							\		*/\n\
							\		public XMLComponent<?> getRootElement() {\n\
							\			return currentElement;\n\
							\		}\n\
							\n\
							\		/** Create a {@link String} describing the current location of the\n\
							\			parser within the source file.\n\
							\n\
							\			@return	A {@link String} showing the current location of the parser\n\
							\					in the source file.\n\
							\		*/\n\
							\		private String getCurrentLocation() {\n\
							\			if (locator != null) {\n\
							\				String location = locator.getSystemId();\n\
							\				int line = locator.getLineNumber();\n\
							\				int column = locator.getColumnNumber();\n\
							\n\
							\				StringBuilder message = new StringBuilder();\n\
							\				if (location != null) {\n\
							\					message.append(location);\n\
							\				} else {\n\
							\					message.append("<unknown>");\n\
							\				}\n\
							\				if (line != -1) {\n\
							\					message.append(''':''');\n\
							\					message.append(line);\n\
							\					if (column != -1) {\n\
							\						message.append(''':''');\n\
							\						message.append(column);\n\
							\					}\n\
							\				}\n\
							\				return message.toString();\n\
							\			}\n\
							\			return null;\n\
							\		}\n\
							\n\
							\		/** Receive characters.\n\
							\n\
							\			@param	ch				A character buffer.\n\
							\			@param	start			The start index of the usable text in the\n\
							\									buffer.\n\
							\			@param	length			The length of the usable text in the buffer.\n\
							\		*/\n\
							\		@Override public void characters(char[] ch, int start, int length) {\n\
							\			StringBuilder sb = new StringBuilder(length);\n\
							\			for (int i = start; i < start + length; i++) {\n\
							\				sb.append(ch[i]);\n\
							\			}\n\
							\			XMLContent content = new XMLContent(sb.toString());\n\
							\			currentElement.add(content);\n\
							\		}\n\
							\n\
							\		/** Handle the end of a document.\n\
							\n\
							\			@throws	SAXException	if an error occurs.\n\
							\		*/\n\
							\		@Override public void endDocument()\n\
							\		throws SAXException\n\
							\		{\n\
							\			if (!elementStack.empty()) {\n\
							\				throw new SAXException("Bad nesting at end of document");\n\
							\			}\n\
							\		}\n\
							\n\
							\		/** Handle the end of an element.\n\
							\n\
							\			@param	uri				The namespace URI or the empty {@link\n\
							\									String} if none.\n\
							\			@param	localName		The unqualified name of the element or the\n\
							\									empty {@link String} if namespace processing\n\
							\									is off.\n\
							\			@param	qName			The fully qualified element name.\n\
							\			@throws	SAXException	if an error occurs.\n\
							\		*/\n\
							\		@Override public void endElement(\n\
							\			String uri,\n\
							\			String localName,\n\
							\			String qName\n\
							\		)\n\
							\		throws SAXException\n\
							\		{\n\
							\			if (!elementStack.empty()) {\n\
							\				XMLComponent<?> oldCurrentElement = currentElement;\n\
							\				currentElement = elementStack.pop();\n\
							\				currentElement.add(oldCurrentElement);\n\
							\			} else {\n\
							\				throw new SAXException("Bad nesting");\n\
							\			}\n\
							\		}\n\
							\n\
							\		/** Handle a processing instruction.\n\
							\n\
							\			@param	target			The target portion of the PI.\n\
							\			@param	data			The data portion of the PI.\n\
							\		*/\n\
							\		@Override public void processingInstruction(String target, String data){\n\
							\			ProcessingInstruction pi = new ProcessingInstruction(target, data);\n\
							\			currentElement.add(pi);\n\
							\		}\n\
							\n\
							\		/** Set the {@link Locator} to use for this content handler.\n\
							\n\
							\			@param	loc	The {@link Locator} to use.\n\
							\		*/\n\
							\		@Override public void setDocumentLocator(Locator loc) {\n\
							\			locator = loc;\n\
							\		}\n\
							\n\
							\		/** Receive notification of a skipped entity.\n\
							\n\
							\			@param	name			The name of the skipped entity.\n\
							\			@throws	SAXException	if an error occurs.\n\
							\		*/\n\
							\		@Override public void skippedEntity(String name)\n\
							\		throws SAXException\n\
							\		{\n\
							\			throw new SAXException(new UnsupportedOperationException());\n\
							\		}\n\
							\n\
							\		/** Handle the start of an element.\n\
							\n\
							\			@param	uri				The namespace URI or the empty {@link\n\
							\									String} if none.\n\
							\			@param	localName		The unqualified name of the element or the\n\
							\									empty {@link String} if namespace processing\n\
							\									is off.\n\
							\			@param	qName			The fully qualified element name.\n\
							\			@param	atts			The {@link Attributes} for this element.\n\
							\			@throws	SAXException	if an error occurs.\n\
							\		*/\n\
							\		@Override public void startElement(\n\
							\			String uri,\n\
							\			String localName,\n\
							\			String qName,\n\
							\			Attributes atts\n\
							\		)\n\
							\		throws SAXException\n\
							\		{\n\
							\			Class<?> elementClass;\n\
							\			try {\n\
							\				elementClass = Class.forName(\n\
							\					"{2}.element." +\n\
							\					localName.substring(0, 1).toUpperCase() +\n\
							\					localName.substring(1)\n\
							\				);\n\
							\			} catch (ClassNotFoundException e) {\n\
							\				StringBuilder message = new StringBuilder("Unknown element \\"");\n\
							\				message.append(localName);\n\
							\				message.append('''"''');\n\
							\				String location = getCurrentLocation();\n\
							\				if (location != null) {\n\
							\					message.append(" at ");\n\
							\					message.append(location);\n\
							\				}\n\
							\				throw new SAXException(message.toString(), e);\n\
							\			}\n\
							\			XMLComponent<?> newElement;\n\
							\			try {\n\
							\				newElement = XMLComponent.class.cast(\n\
							\					elementClass.newInstance()\n\
							\				);\n\
							\			} catch (IllegalAccessException e) {\n\
							\				throw new SAXException(e);\n\
							\			} catch (InstantiationException e) {\n\
							\				throw new SAXException(e);\n\
							\			}\n\
							\			for (int i = 0; i < atts.getLength(); i++) {\n\
							\				String name = atts.getLocalName(i);\n\
							\				String value = atts.getValue(i);\n\
							\				StringBuilder methodName = new StringBuilder("set");\n\
							\				methodName.append(name.substring(0, 1).toUpperCase());\n\
							\				methodName.append(name.substring(1));\n\
							\				Method attMethod;\n\
							\				try {\n\
							\					attMethod = elementClass.getMethod(\n\
							\						methodName.toString(),\n\
							\						String.class\n\
							\					);\n\
							\				} catch (NoSuchMethodException e) {\n\
							\					throw new SAXException(e);\n\
							\				}\n\
							\				try {\n\
							\					attMethod.invoke(newElement, value);\n\
							\				} catch (IllegalAccessException e) {\n\
							\					throw new SAXException(e);\n\
							\				} catch (IllegalArgumentException e) {\n\
							\					throw new SAXException(e);\n\
							\				} catch (InvocationTargetException e) {\n\
							\					throw new SAXException(e);\n\
							\				}\n\
							\			}\n\
							\			if (currentElement != null) {\n\
							\				elementStack.push(currentElement);\n\
							\			}\n\
							\			currentElement = newElement;\n\
							\		}\n\
							\n\
							\	}\n\
							\n\
							\	/** A synthetic root element for the tree of elements.\n\
							\n\
							\		@author	{0}\n\
							\		@since	{1}\n\
							\	*/\n\
							\	public static class DocumentRootElement\n\
							\	extends XMLComponent<DocumentRootElement>\n\
							\	{\n\
							\		/** {@inheritDoc} */\n\
							\		@Override public void write(Writer w, int depth)\n\
							\		throws IOException\n\
							\		{\n\
							\			for (XMLComponent<?> xc : children) {\n\
							\				xc.write(w, depth);\n\
							\			}\n\
							\		}\n\
							\n\
							\		/** {@inheritDoc} */\n\
							\		public int compareTo(XMLComponent<?> other) {\n\
							\			Iterator<XMLComponent<?>> thisIter = children.iterator();\n\
							\			Iterator<XMLComponent<?>> otherIter = getChildren().iterator();\n\
							\			while (thisIter.hasNext() && otherIter.hasNext()) {\n\
							\				XMLComponent<?> thisItem = thisIter.next();\n\
							\				XMLComponent<?> otherItem = otherIter.next();\n\
							\				int itemCmp = thisItem.compareTo(otherItem);\n\
							\				if (itemCmp != 0) {\n\
							\					return itemCmp;\n\
							\				}\n\
							\			}\n\
							\			if (thisIter.hasNext()) {\n\
							\				return 1;\n\
							\			}\n\
							\			if (otherIter.hasNext()) {\n\
							\				return -1;\n\
							\			}\n\
							\n\
							\			return 0;\n\
							\		}\n\
							\	}\n\
							\}\n
XML_COMPONENT_CLASS	=		\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\import java.io.IOException;\n\
							\import java.io.StringWriter;\n\
							\import java.io.Writer;\n\
							\import java.util.ArrayList;\n\
							\import java.util.List;\n\
							\n\
							\/** An XML document is made up of {@link XMLComponent}s.\n\
							\n\
							\	@author		{0}\n\
							\	@since		{1}\n\
							\	@param	<T>	The type of {@link XMLComponent} this is.\n\
							\*/\n\
							\public abstract class XMLComponent<T extends XMLComponent<T>>\n\
							\implements Comparable<XMLComponent<?>>\n\
							\{\n\
							\	/** The local end-of-line character sequence. */\n\
							\	protected static final String EOL = System.getProperty("line.separator");\n\
							\n\
							\	/** The magic value used in generating hash codes. */\n\
							\	protected static final int HASHCODE_MAGIC = 29;\n\
							\n\
							\	/** The parent element for this {@link XMLComponent}, null for top-level\n\
							\		components.\n\
							\	*/\n\
							\	protected XMLComponent<?> parent;\n\
							\n\
							\	/** The children of this {@link XMLComponent}. */\n\
							\	protected final List<XMLComponent<?>> children;\n\
							\n\
							\	/** Create a new blank {@link XMLComponent}. */\n\
							\	protected XMLComponent() {\n\
							\		parent = null;\n\
							\		children = new ArrayList<XMLComponent<?>>();\n\
							\	}\n\
							\n\
							\	/** Get the parent of this {@link XMLComponent}.\n\
							\n\
							\		@return	The parent of this {@link XMLComponent}.\n\
							\	*/\n\
							\	public XMLComponent<?> getParent() {\n\
							\		return parent;\n\
							\	}\n\
							\n\
							\	/** Set the parent element of this {@link XMLComponent}.\n\
							\n\
							\		@param	parentComponent	The parent for this {@link XMLComponent}.\n\
							\	*/\n\
							\	public void setParent(XMLComponent<?> parentComponent) {\n\
							\		parent = parentComponent;\n\
							\	}\n\
							\n\
							\	/** Get any contained {@link XMLComponent}s.\n\
							\n\
							\		@return	All contained {@link XMLComponent}s.\n\
							\	*/\n\
							\	public List<XMLComponent<?>> getChildren() {\n\
							\		return new ArrayList<XMLComponent<?>>(children);\n\
							\	}\n\
							\n\
							\	/** Set the child {@link XMLComponent}s.\n\
							\n\
							\		@param	newChildren	The child components for this {@link XMLComponent}.\n\
							\	*/\n\
							\	public void setChildren(List<XMLComponent<?>> newChildren) {\n\
							\		children.clear();\n\
							\		children.addAll(newChildren);\n\
							\	}\n\
							\n\
							\	/** Add a child component to this one.\n\
							\n\
							\		@param	child	The child component to add.\n\
							\	*/\n\
							\	public void add(XMLComponent<?> child) {\n\
							\		child.setParent(this);\n\
							\		children.add(child);\n\
							\	}\n\
							\n\
							\	/**	Test whether or not this component has a child of a particular type.\n\
							\n\
							\		@param	containedClass	The type of the child to find.\n\
							\		@return					True if at least one of the children is of then\n\
							\								specified type, false otherwise.\n\
							\	*/\n\
							\	public boolean contains(Class<?> containedClass) {\n\
							\		if (containedClass.isAssignableFrom(getClass())) {\n\
							\			return true;\n\
							\		}\n\
							\		for (XMLComponent<?> child : getChildren()) {\n\
							\			if (child.contains(containedClass)) {\n\
							\				return true;\n\
							\			}\n\
							\		}\n\
							\		return false;\n\
							\	}\n\
							\n\
							\	/** Shorthand for writing at depth 0.\n\
							\n\
							\		@param	w			The {@link Writer} to write to.\n\
							\		@throws	IOException	if the {@link Writer} throws one.\n\
							\	*/\n\
							\	public void write(Writer w) throws IOException {\n\
							\		write(w, 0);\n\
							\	}\n\
							\n\
							\	/** Write out the XML component.\n\
							\n\
							\		@param	w			The {@link Writer} to write to.\n\
							\		@param	depth		The depth of indenting to go to.\n\
							\		@throws	IOException	if the {@link Writer} throws one.\n\
							\	*/\n\
							\	public abstract void write(Writer w, int depth) throws IOException;\n\
							\n\
							\	/** Override {@link Object#toString()} to produce the XML representation\n\
							\		of this component.\n\
							\n\
							\		@return	The XML representation of this component or null on error.\n\
							\	*/\n\
							\	@Override public String toString() {\n\
							\		StringWriter sw = new StringWriter();\n\
							\		try {\n\
							\			write(sw);\n\
							\			sw.flush();\n\
							\			sw.close();\n\
							\			return sw.toString();\n\
							\		} catch (IOException e) {\n\
							\			assert e != null;\n\
							\			return null;\n\
							\		}\n\
							\	}\n\
							\}\n
XML_CONTENT_CLASS	=		\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\import java.io.IOException;\n\
							\import java.io.Writer;\n\
							\n\
							\/** Represent text content in an XML document.\n\
							\n\
							\	@author	{0}\n\
							\	@since	{1}\n\
							\*/\n\
							\public class XMLContent\n\
							\extends XMLComponent<XMLContent>\n\
							\{\n\
							\	/** The text content itself. */\n\
							\	private String content;\n\
							\n\
							\	/** Create an {@link XMLContent} element.\n\
							\n\
							\		@param	text	The text of the {@link XMLContent}.\n\
							\	*/\n\
							\	public XMLContent(String text) {\n\
							\		super();\n\
							\		if (content != null) {\n\
							\			content = text;\n\
							\		} else {\n\
							\			content = "";\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	@Override public void write(Writer w, int depth)\n\
							\	throws IOException\n\
							\	{\n\
							\		for (int i = 0; i < depth; i++) {\n\
							\			w.write("    ");\n\
							\		}\n\
							\		w.write(content);\n\
							\	}\n\
							\n\
							\	/** Append another {@link XMLContent} onto this one.\n\
							\n\
							\		@param	other	The {@link XMLContent} to append to this one.\n\
							\	*/\n\
							\	public void append(XMLContent other) {\n\
							\		if (other != null) {\n\
							\			content += other.getContent();\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** Get the text content for this {@link XMLContent}.\n\
							\n\
							\		@return	The text content.\n\
							\	*/\n\
							\	public String getContent() {\n\
							\		return content;\n\
							\	}\n\
							\n\
							\	/** Check if this {@link XMLContent} consists solely of whitespace.\n\
							\n\
							\		@return	True if there is nothing but whitespace in this {@link\n\
							\				XMLContent}.\n\
							\	*/\n\
							\	public boolean isAllWhitespace() {\n\
							\		return content.matches("^\\\\s*$");\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	public int compareTo(XMLComponent<?> other) {\n\
							\		return content.compareTo(XMLContent.class.cast(other).getContent());\n\
							\	}\n\
							\n\
							\	/** Implement {@link Object#equals(Object)}.\n\
							\n\
							\		@param	o	The object to compare against.\n\
							\		@return		True if this is equal to o, false otherwise.\n\
							\	*/\n\
							\	@Override public boolean equals(Object o) {\n\
							\		if (this == o) {\n\
							\			return true;\n\
							\		}\n\
							\		if (o == null) {\n\
							\			return false;\n\
							\		}\n\
							\		if (!(o instanceof XMLContent)) {\n\
							\			return false;\n\
							\		}\n\
							\n\
							\		return compareTo(XMLContent.class.cast(o)) == 0;\n\
							\	}\n\
							\n\
							\	/** Implement {@link Object#hashCode()}.\n\
							\n\
							\		@return	A hash code for this object.\n\
							\	*/\n\
							\	@Override public int hashCode() {\n\
							\		return content.hashCode();\n\
							\	}\n\
							\}\n
EXCEPTION_CLASS	=			\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\/** An exception which may be thrown during parsing or processing.\n\
							\n\
							\	@author	{0}\n\
							\	@since	{1}\n\
							\*/\n\
							\public class {3}\n\
							\extends Exception\n\
							\{\n\
							\	/** Create a new {@link {3}}. */\n\
							\	public {3}() {\n\
							\		super();\n\
							\	}\n\
							\n\
							\	/** Create a new {@link {3}} with a message.\n\
							\n\
							\		@param	message	A message explaining why this exception is being thrown.\n\
							\	*/\n\
							\	public {3}(String message) {\n\
							\		super(message);\n\
							\	}\n\
							\n\
							\	/** Create a new {@link {3}} with a reference to another\n\
							\		{@link Throwable} which caused it to be thrown.\n\
							\n\
							\		@param	throwable	The {@link Throwable} which caused this {@link\n\
							\							Exception} to be thrown.\n\
							\	*/\n\
							\	public {3}(Throwable throwable) {\n\
							\		super(throwable);\n\
							\	}\n\
							\n\
							\	/** Create a new {@link {3}} with a message and a reference\n\
							\		to another {@link Throwable} which caused it to be thrown.\n\
							\n\
							\		@param	message		A message explaining why this exception is being\n\
							\							thrown.\n\
							\		@param	throwable	The {@link Throwable} which caused this {@link\n\
							\							Exception} to be thrown.\n\
							\	*/\n\
							\	public {3}(String message, Throwable throwable) {\n\
							\		super(message, throwable);\n\
							\	}\n\
							\n\
							\	/** Implement {@link Object#equals(Object)}.\n\
							\n\
							\		@param	o	The {@link Object} to test for equality.\n\
							\		@return		True if this is equal to o, false otherwise.\n\
							\	*/\n\
							\	@Override public boolean equals(Object o) {\n\
							\		if (this == o) {\n\
							\			return true;\n\
							\		}\n\
							\		if (o == null) {\n\
							\			return false;\n\
							\		}\n\
							\		if (!(o instanceof {3})) {\n\
							\			return false;\n\
							\		}\n\
							\n\
							\		return throwablesEqual(this, {3}.class.cast(o));\n\
							\	}\n\
							\n\
							\	/** Implement {@link Object#hashCode()}.\n\
							\n\
							\		@return A hash code for this object.\n\
							\	*/\n\
							\	@Override public int hashCode() {\n\
							\		String message = getMessage();\n\
							\		Throwable cause = getCause();\n\
							\n\
							\		int hashCode = getClass().hashCode();\n\
							\		if (message != null && cause != null) {\n\
							\			hashCode *= message.hashCode() * cause.hashCode();\n\
							\		} else if (message != null) {\n\
							\			hashCode *= message.hashCode();\n\
							\		} else if (cause != null) {\n\
							\			hashCode *= cause.hashCode();\n\
							\		}\n\
							\		return hashCode;\n\
							\	}\n\
							\n\
							\	/** Recursively test that two {@link Throwable}s are equal. This is\n\
							\		necessary because {@link Throwable} uses the default {@link\n\
							\		Object#equals(Object)} which only compares referential equality.\n\
							\
							\		@param	a	The first of the two {@link Throwable}s.\n\
							\		@param	b	The second of the two {@link Throwable}s.\n\
							\		@return		True if the two {@link Throwable}s are equal.\n\
							\	*/\n\
							\	private static boolean throwablesEqual(Throwable a, Throwable b) {\n\
							\		if (a != null && b != null) {\n\
							\			if (throwablesEqual(a.getCause(), b.getCause())) {\n\
							\				// Compare the messages\n\
							\				String aMessage = a.getMessage();\n\
							\				String bMessage = b.getMessage();\n\
							\				if (aMessage != null && bMessage != null) {\n\
							\					if (!aMessage.equals(bMessage)) {\n\
							\						return false;\n\
							\					}\n\
							\				} else if (aMessage != null || bMessage != null) {\n\
							\					return false;\n\
							\				}\n\
							\n\
							\				// Compare the stacktraces\n\
							\				StackTraceElement[] aTrace = a.getStackTrace();\n\
							\				StackTraceElement[] bTrace = b.getStackTrace();\n\
							\				if (aTrace != null && bTrace != null) {\n\
							\					if (aTrace.length != bTrace.length) {\n\
							\						return false;\n\
							\					}\n\
							\					for (int i = 0; i < aTrace.length; i++) {\n\
							\						if (!aTrace[i].equals(bTrace[i])) {\n\
							\							return false;\n\
							\						}\n\
							\					}\n\
							\					return true;\n\
							\				} else {\n\
							\					return aTrace == null && bTrace == null;\n\
							\				}\n\
							\			} else {\n\
							\				return false;\n\
							\			}\n\
							\		} else if (a != null || b != null) {\n\
							\			return false;\n\
							\		} else {\n\
							\			return true;\n\
							\		}\n\
							\	}\n\
							\}\n
TREEOP_INTERFACE	=		\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\/** An interface for all operations on trees of elements produced by {@link\n\
							\	{3}}.\n\
							\n\
							\	@author	{0}\n\
							\	@since	{1}\n\
							\*/\n\
							\public interface {3} {\n\
							\	/** Decide whether or not this operation should be performed on a given\n\
							\		node.\n\
							\n\
							\		@param	treeComponent	The node in the tree to operate on.\n\
							\		@return					True if the node should be operated on,\n\
							\								false otherwise.\n\
							\	*/\n\
							\	boolean shouldApply(XMLComponent<?> treeComponent);\n\
							\n\
							\	/** Do the operation on the given node.\n\
							\n\
							\		@param	treeComponent		The node in the tree to operate on.\n\
							\		@throws	{4}		if an error occurs.\n\
							\	*/\n\
							\	void execute(XMLComponent<?> treeComponent) throws {4};\n\
							\}\n
