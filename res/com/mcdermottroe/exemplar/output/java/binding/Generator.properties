# vim:filetype=jproperties:ts=4
#
# Copyright (c) 2007
# Conor McDermottroe.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the author nor the names of any contributors to
#    the software may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
# OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
ABSTRACT_ELEMENT_CLASS	=	\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\import java.io.IOException;\n\
							\import java.io.StringWriter;\n\
							\import java.io.Writer;\n\
							\import java.util.ArrayList;\n\
							\import java.util.Iterator;\n\
							\import java.util.List;\n\
							\import java.util.Map;\n\
							\import java.util.SortedMap;\n\
							\import java.util.TreeMap;\n\
							\n\
							\public abstract class {0}Element extends XMLComponent {\n\
							\	/** The attributes, if any. */\n\
							\	protected SortedMap attributes;\n\
							\n\
							\	/** The contained elements, if any. */\n\
							\	protected List contents;\n\
							\n\
							\	/** The name of the element. */\n\
							\	protected String name;\n\
							\n\
							\	/** Create a new {0}Element.\n\
							\n\
							\		@param	elementName	The name of the element.\n\
							\	*/\n\
							\	protected {0}Element(String elementName) {\n\
							\		name = elementName;\n\
							\		attributes = new TreeMap();\n\
							\	}\n\
							\n\
							\	public void add(XMLComponent child) {\n\
							\		if (contents == null) {\n\
							\			contents = new ArrayList();\n\
							\		}\n\
							\		contents.add(child);\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	public void write(Writer w, int depth)\n\
							\	throws IOException\n\
							\	{\n\
							\		for (int i = 0; i < depth; i++) {\n\
							\			w.write("    ");\n\
							\		}\n\
							\		w.write("<");\n\
							\		w.write(name);\n\
							\		if (!attributes.isEmpty()) {\n\
							\			for (Iterator i = attributes.values().iterator(); i.hasNext(); ) {\n\
							\				Attribute att = (Attribute)i.next();\n\
							\				att.write(w, depth);\n\
							\			}\n\
							\		}\n\
							\		if (contents == null) {\n\
							\			w.write(" />");\n\
							\		} else {\n\
							\			w.write(">\\n");\n\
							\			for (Iterator i = contents.iterator(); i.hasNext(); ) {\n\
							\				XMLComponent x = (XMLComponent)i.next();\n\
							\				x.write(w, depth + 1);\n\
							\			}\n\
							\			w.write("</");\n\
							\			w.write(name);\n\
							\			w.write(">");\n\
							\		}\n\
							\		w.write("\\n");\n\
							\	}\n\
							\n\
							\	public String toString() {\n\
							\		StringWriter sw = new StringWriter();\n\
							\		try {\n\
							\			write(sw);\n\
							\			return sw.toString();\n\
							\		} catch (IOException e) {\n\
							\			e.printStackTrace();\n\
							\			return null;\n\
							\		}\n\
							\	}\n\
							\n\
							\	/** A class to wrap the notion of an XML attribute. */\n\
							\	protected class Attribute extends XMLComponent implements Comparable {\n\
							\		/** An attribute which is not FIXED, IMPLIED or REQUIRED. */\n\
							\		public static final int DEFAULT = 0;\n\
							\n\
							\		/** An attribute which is FIXED. */\n\
							\		public static final int FIXED = 1;\n\
							\n\
							\		/** An attribute which is IMPLIED. */\n\
							\		public static final int IMPLIED = 2;\n\
							\n\
							\		/** An attribute which is REQUIRED. */\n\
							\		public static final int REQUIRED = 3;\n\
							\n\
							\		/** The attribute's default value if any. */\n\
							\		private final String defaultValue;\n\
							\n\
							\		/** The name of the attribute. */\n\
							\		private final String name;\n\
							\n\
							\		/** The type of the attribute. */\n\
							\		private final int type;\n\
							\n\
							\		/** The attribute's current value, if any. */\n\
							\		private String value = null;\n\
							\n\
							\		/** This is set if the attribute has been given a value. */\n\
							\		private boolean isSet;\n\
							\n\
							\		/** Create a new Attribute.\n\
							\n\
							\			@param	attName   The name of the attribute.\n\
							\			@param	attType   The type of the attribute.\n\
							\			@param	defValue  The default value for the attribute, if appropriate.\n\
							\		*/\n\
							\		public Attribute(String attName, int attType, String defValue) {\n\
							\			name = attName;\n\
							\			type = attType;\n\
							\			if (attType == DEFAULT || attType == FIXED) {\n\
							\				if (defValue != null) {\n\
							\					defaultValue = defValue;\n\
							\					value = defValue;\n\
							\				} else {\n\
							\					throw new UnsupportedOperationException("The default value of an attribute may not be null");\n\
							\				}\n\
							\			} else {\n\
							\				if (defValue != null) {\n\
							\					throw new UnsupportedOperationException("Default values may not be provided for REQUIRED or IMPLIED attributes.");\n\
							\				}\n\
							\				defaultValue = null;\n\
							\			}\n\
							\			isSet = false;\n\
							\		}\n\
							\n\
							\		/** Implementation of {@link Comparable#compareTo(Object)}. */\n\
							\		public int compareTo(Object o) {\n\
							\			if (o instanceof Attribute) {\n\
							\				return name.compareTo(((Attribute)o).name);\n\
							\			} else {\n\
							\				throw new ClassCastException("Attributes may only be compared with other Attributes");\n\
							\			}\n\
							\		}\n\
							\n\
							\		public String getDefaultValue() {\n\
							\			if (defaultValue != null) {\n\
							\				return defaultValue;\n\
							\			} else {\n\
							\				throw new UnsupportedOperationException(name + " attributes do not have a default.");\n\
							\			}\n\
							\		}\n\
							\n\
							\		public String getName() {\n\
							\			return name;\n\
							\		}\n\
							\n\
							\		public int getType() {\n\
							\			return type;\n\
							\		}\n\
							\n\
							\		public String getValue() {\n\
							\			return value;\n\
							\		}\n\
							\n\
							\		public void setValue(String val) {\n\
							\			if (type == FIXED) {\n\
							\				throw new UnsupportedOperationException("Cannot set value, attribute " + name + " is a FIXED attribute");\n\
							\			}\n\
							\			value = val;\n\
							\			isSet = true;\n\
							\		}\n\
							\n\
							\		/** {@inheritDoc} */\n\
							\		public void write(Writer w, int depth)\n\
							\		throws IOException\n\
							\		{\n\
							\			if (value == null) {\n\
							\				return;\n\
							\			}\n\
							\			if (value.equals(defaultValue)) {\n\
							\				return;\n\
							\			}\n\
							\			if (!isSet) {\n\
							\				return;\n\
							\			}\n\
							\			w.write(" ");\n\
							\			w.write(name);\n\
							\			w.write("=\\"");\n\
							\			w.write(value);\n\
							\			w.write("\\"");\n\
							\		}\n\
							\	}\n\
							\}\n
ELEMENT_CLASS	=			\/* Generated by {0} on {1}. */\n\
							\package {2}.element;\n\
							\n\
							\import {2}.support.{0}Element;\n\
							\n\
							\/** A class for representing {3} elements. */\n\
							\public class {4} extends {0}Element {\n\
							\	/** Create a {3} element object. */\n\
							\	public {4}() {\n\
							\		super("{3}");\n\
							\{5}\n\
							\	}\n\
							\{6}\n\
							\}\n
PI_CLASS	=				\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\import java.io.IOException;\n\
							\import java.io.Writer;\n\
							\n\
							\public class ProcessingInstruction extends XMLComponent {\n\
							\	private final String piTarget;\n\
							\n\
							\	private final String piData;\n\
							\n\
							\	public ProcessingInstruction(String target, String data) {\n\
							\		piTarget = target;\n\
							\		piData = data;\n\
							\	}\n\
							\n\
							\	public void write(Writer w, int depth) throws IOException {\n\
							\		for (int i = 0; i < depth; i++) {\n\
							\			w.write("    ");\n\
							\		}\n\
							\		w.write("<?");\n\
							\		w.write(piTarget);\n\
							\		w.write(" ");\n\
							\		w.write(piData);\n\
							\		w.write("?>");\n\
							\		w.write("\\n");\n\
							\	}\n\
							\}\n
ROOT_PARSER_CLASS	=		\/* Generated by {0} on {1}. */\n\
							\package {2};\n\
							\n\
							\import java.lang.reflect.InvocationTargetException;\n\
							\import java.lang.reflect.Method;\n\
							\import java.io.BufferedReader;\n\
							\import java.io.BufferedWriter;\n\
							\import java.io.File;\n\
							\import java.io.FileNotFoundException;\n\
							\import java.io.FileReader;\n\
							\import java.io.FileWriter;\n\
							\import java.io.IOException;\n\
							\import java.io.InputStream;\n\
							\import java.io.InputStreamReader;\n\
							\import java.io.OutputStream;\n\
							\import java.io.OutputStreamWriter;\n\
							\import java.util.HashMap;\n\
							\import java.util.Map;\n\
							\import java.util.Stack;\n\
							\n\
							\import org.xml.sax.Attributes;\n\
							\import org.xml.sax.ContentHandler;\n\
							\import org.xml.sax.ErrorHandler;\n\
							\import org.xml.sax.InputSource;\n\
							\import org.xml.sax.Locator;\n\
							\import org.xml.sax.SAXException;\n\
							\import org.xml.sax.SAXParseException;\n\
							\import org.xml.sax.XMLReader;\n\
							\import org.xml.sax.helpers.XMLReaderFactory;\n\
							\n\
							\import {2}.support.ProcessingInstruction;\n\
							\import {2}.support.XMLComponent;\n\
							\import {2}.support.XMLContent;\n\
							\import {2}.support.{0}Element;\n\
							\n\
							\public class {3} {\n\
							\	/** Read the document from a {@link BufferedReader}. */\n\
							\	private static XMLComponent read(BufferedReader reader)\n\
							\	throws IOException, SAXException\n\
							\	{\n\
							\		XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n\
							\		xmlReader.setErrorHandler(\n\
							\			new ErrorHandler() {\n\
							\				public void error(SAXParseException exception)\n\
							\				throws SAXException\n\
							\				{\n\
							\					throw new SAXException(exception);\n\
							\				}\n\
							\n\
							\				public void fatalError(SAXParseException exception)\n\
							\				throws SAXException\n\
							\				{\n\
							\					throw new SAXException(exception);\n\
							\				}\n\
							\n\
							\				public void warning(SAXParseException exception)\n\
							\				throws SAXException\n\
							\				{\n\
							\					throw new SAXException(exception);\n\
							\				}\n\
							\			}\n\
							\		);\n\
							\		{3}ContentHandler contentHandler = new {3}ContentHandler();\n\
							\		xmlReader.setContentHandler(contentHandler);\n\
							\		xmlReader.parse(new InputSource(reader));\n\
							\		return contentHandler.getRootElement();\n\
							\	}\n\
							\n\
							\	/** Read the document from a {@link InputStreeam}. */\n\
							\	public static XMLComponent read(InputStream input)\n\
							\	throws IOException, SAXException\n\
							\	{\n\
							\		return read(new BufferedReader(new InputStreamReader(input)));\n\
							\	}\n\
							\n\
							\	/** Read the document from a {@link File}. */\n\
							\	public static XMLComponent read(File file)\n\
							\	throws FileNotFoundException, IOException, SAXException\n\
							\	{\n\
							\		return read(new BufferedReader(new FileReader(file)));\n\
							\	}\n\
							\n\
							\	/** Write a document from a root element to a {@link BufferedWriter}. */\n\
							\	private static void write(XMLComponent rootElement, BufferedWriter writer)\n\
							\	throws IOException\n\
							\	{\n\
							\		if (rootElement != null) {\n\
							\			writer.write("<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" ?>\\n");\n\
							\			rootElement.write(writer);\n\
							\		}\n\
							\		writer.flush();\n\
							\	}\n\
							\n\
							\	/** Write a document from a root element to an {@link OutputStream}. */\n\
							\	public static void write(XMLComponent rootElement, OutputStream output)\n\
							\	throws IOException\n\
							\	{\n\
							\		write(rootElement, new BufferedWriter(new OutputStreamWriter(output)));\n\
							\	}\n\
							\n\
							\	/** Write a document from a root element to a {@link File}. */\n\
							\	public static void write(XMLComponent rootElement, File file)\n\
							\	throws IOException\n\
							\	{\n\
							\		write(rootElement, new BufferedWriter(new FileWriter(file)));\n\
							\	}\n\
							\n\
							\	private static class {3}ContentHandler\n\
							\	implements ContentHandler\n\
							\	{\n\
							\		private {0}Element currentElement;\n\
							\n\
							\		private Stack elementStack;\n\
							\n\
							\		private Locator locator;\n\
							\n\
							\		private Map prefixMapping;\n\
							\n\
							\		public {3}ContentHandler() {\n\
							\			currentElement = null;\n\
							\			elementStack = new Stack();\n\
							\			locator = null;\n\
							\			prefixMapping = new HashMap();\n\
							\		}\n\
							\n\
							\		public {0}Element getRootElement() {\n\
							\			return currentElement;\n\
							\		}\n\
							\n\
							\		public void characters(char[] ch, int start, int length)\n\
							\		throws SAXException\n\
							\		{\n\
							\			StringBuilder sb = new StringBuilder(length);\n\
							\			for (int i = start; i < start + length; i++) {\n\
							\				sb.append(ch[i]);\n\
							\			}\n\
							\			XMLContent content = new XMLContent(sb.toString());\n\
							\			currentElement.add(content);\n\
							\		}\n\
							\n\
							\		public void endDocument()\n\
							\		throws SAXException\n\
							\		{\n\
							\			assert elementStack.empty();\n\
							\		}\n\
							\n\
							\		public void endElement(String uri, String localName, String qName)\n\
							\		throws SAXException\n\
							\		{\n\
							\			if (!elementStack.empty()) {\n\
							\				XMLComponent oldCurrentElement = currentElement;\n\
							\				currentElement = ({0}Element)elementStack.pop();\n\
							\				currentElement.add(oldCurrentElement);\n\
							\			}\n\
							\		}\n\
							\n\
							\		public void endPrefixMapping(String prefix)\n\
							\		throws SAXException\n\
							\		{\n\
							\		}\n\
							\n\
							\		public void ignorableWhitespace(char[] ch, int start, int length)\n\
							\		throws SAXException\n\
							\		{\n\
							\			// We ignore this\n\
							\		}\n\
							\n\
							\		public void processingInstruction(String target, String data)\n\
							\		throws SAXException\n\
							\		{\n\
							\			ProcessingInstruction pi = new ProcessingInstruction(target, data);\n\
							\			currentElement.add(pi);\n\
							\		}\n\
							\n\
							\		public void setDocumentLocator(Locator loc) {\n\
							\			locator = loc;\n\
							\		}\n\
							\n\
							\		public void skippedEntity(String name)\n\
							\		throws SAXException\n\
							\		{\n\
							\			throw new SAXException(new UnsupportedOperationException());\n\
							\		}\n\
							\n\
							\		public void startDocument()\n\
							\		throws SAXException\n\
							\		{\n\
							\		}\n\
							\n\
							\		public void startElement(String uri, String localName, String qName, Attributes atts)\n\
							\		throws SAXException\n\
							\		{\n\
							\			Class elementClass;\n\
							\			try {\n\
							\				elementClass = Class.forName("{2}.element." + localName.substring(0, 1).toUpperCase() + localName.substring(1));\n\
							\			} catch (ClassNotFoundException e) {\n\
							\				throw new SAXException(e);\n\
							\			}\n\
							\			{0}Element newElement;\n\
							\			try {\n\
							\				newElement = ({0}Element)elementClass.newInstance();\n\
							\			} catch (IllegalAccessException e) {\n\
							\				throw new SAXException(e);\n\
							\			} catch (InstantiationException e) {\n\
							\				throw new SAXException(e);\n\
							\			}\n\
							\			for (int i = 0; i < atts.getLength(); i++) {\n\
							\				String name = atts.getLocalName(i);\n\
							\				String value = atts.getValue(i);\n\
							\				String methodName = "set" + name.substring(0,1).toUpperCase() + name.substring(1);\n\
							\				Method attMethod;\n\
							\				try {\n\
							\					attMethod = elementClass.getMethod(methodName, new Class[] { String.class });\n\
							\				} catch (NoSuchMethodException e) {\n\
							\					throw new SAXException(e);\n\
							\				}\n\
							\				try {\n\
							\					attMethod.invoke(newElement, new Object[] { value });\n\
							\				} catch (IllegalAccessException e) {\n\
							\					throw new SAXException(e);\n\
							\				} catch (IllegalArgumentException e) {\n\
							\					throw new SAXException(e);\n\
							\				} catch (InvocationTargetException e) {\n\
							\					throw new SAXException(e);\n\
							\				}\n\
							\			}\n\
							\			if (currentElement != null) {\n\
							\				elementStack.push(currentElement);\n\
							\			}\n\
							\			currentElement = newElement;\n\
							\		}\n\
							\n\
							\		public void startPrefixMapping(String prefix, String uri)\n\
							\		throws SAXException\n\
							\		{\n\
							\			prefixMapping.put(prefix, uri);\n\
							\		}\n\
							\	}\n\
							\}\n
XML_COMPONENT_CLASS	=		\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\import java.io.IOException;\n\
							\import java.io.Writer;\n\
							\n\
							\/** An {@link XMLDocument} is made up of {@link XMLComponent}s. */\n\
							\public abstract class XMLComponent {\n\
							\	/** Shorthand for writing at depth 0.\n\
							\n\
							\		@param	w			The {@link Writer} to write to.\n\
							\		@throws	IOException	if the {@link Writer} throws one.\n\
							\	*/\n\
							\	public void write(Writer w) throws IOException {\n\
							\		write(w, 0);\n\
							\	}\n\
							\n\
							\	/** Write out the XML component.\n\
							\n\
							\		@param	w			The {@link Writer} to write to.\n\
							\		@param	depth		The depth of indenting to go to.\n\
							\		@throws	IOException	if the {@link Writer} throws one.\n\
							\	*/\n\
							\	public abstract void write(Writer w, int depth) throws IOException;\n\
							\}\n
XML_CONTENT_CLASS	=		\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\import java.io.IOException;\n\
							\import java.io.Writer;\n\
							\/** Represent text content in an {@link XMLDocument}. */\n\
							\public class XMLContent extends XMLComponent {\n\
							\	/** The text content itself. */\n\
							\	private String content;\n\
							\n\
							\	/** Create an {@link XMLContent} element. */\n\
							\	public XMLContent(String text) {\n\
							\		content = text;\n\
							\	}\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	public void write(Writer w, int depth) throws IOException {\n\
							\		for (int i = 0; i < depth; i++) {\n\
							\			w.write("    ");\n\
							\		}\n\
							\		w.write(content);\n\
							\	}\n\
							\}\n
XML_DOCUMENT_CLASS	=		\/* Generated by {0} on {1}. */\n\
							\package {2}.support;\n\
							\n\
							\import java.io.IOException;\n\
							\import java.io.Writer;\n\
							\n\
							\/** A representation of an XML document. */\n\
							\public class XMLDocument extends XMLComponent {\n\
							\	/** The root element of the XML document. */\n\
							\	private {0}Element rootElement;\n\
							\n\
							\	/** The xml declaration at the start, if any. */\n\
							\	private String xmlDeclaration;\n\
							\n\
							\	/** {@inheritDoc} */\n\
							\	public void write(Writer w, int depth) throws IOException;\n\
							\}\n
