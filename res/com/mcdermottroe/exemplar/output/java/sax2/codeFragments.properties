# vim:filetype=jproperties:ts=4
#
# Copyright (c) 2005, 2006
# Conor McDermottroe.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the author nor the names of any contributors to
#    the software may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
# OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
JAVA_MAIN_TEMPLATE =	\/*\n\
						\	Generated by {0} on {1}\n\
						\*/\n\
						\{4}\n\n\
						\import java.io.BufferedReader;\n\
						\import java.io.IOException;\n\
						\import java.io.InputStreamReader;\n\
						\import java.io.Reader;\n\
						\ \n\
						\import org.xml.sax.ContentHandler;\n\
						\import org.xml.sax.DTDHandler;\n\
						\import org.xml.sax.EntityResolver;\n\
						\import org.xml.sax.ErrorHandler;\n\
						\import org.xml.sax.InputSource;\n\
						\import org.xml.sax.SAXException;\n\n\
						\import org.xml.sax.SAXNotRecognizedException;\n\n\
						\import org.xml.sax.SAXParseException;\n\
						\import org.xml.sax.XMLReader;\n\
						\import org.xml.sax.helpers.DefaultHandler;\n\
						\ \n\
						\/** An instance of the SAX 2.0 Reader interface\n\
						\	specifically made for {2}\n\
						\*/\n\
						\class {2}Reader implements XMLReader {\n\
						\	/** Whether or not namespaces are processed. */\n\
						\	public boolean feature_namespaces;\n\
						\	/** Whether or not namespace prefixes are processed. */\n\
						\	public boolean feature_namespace_prefixes;\n\
						\ \n\
						\	/** A reference to the currently selected ContentHandler. */\n\
						\	public ContentHandler contentHandler;\n\
						\	/** A reference to the currently selected DTDHandler. */\n\
						\	private DTDHandler dtdHandler;\n\
						\	/** A reference to the currently selected EntityResolver. */\n\
						\	private EntityResolver entityResolver;\n\
						\	/** A reference to the currently selected ErrorHandler. */\n\
						\	private ErrorHandler errorHandler;\n\n\
						\	/** Make a new {2}Reader.\n\n\
						\		Everything uses the default handler.\n\n\
						\	*/\n\
						\	public {2}Reader() {\n\
						\		// By default all namespace feeatures are ignored.\n\
						\		feature_namespaces = false;\n\
						\		feature_namespace_prefixes = false;\n\
						\ \n\
						\		// Make the default handler\n\
						\		DefaultHandler defaultHandler = new DefaultHandler();\n\n\
						\		// Make everything point to the default handler\n\
						\		contentHandler = defaultHandler;\n\
						\		dtdHandler = defaultHandler;\n\
						\		entityResolver = defaultHandler;\n\
						\		errorHandler = defaultHandler;\n\
						\	}\n\
						\ \n\
						\	/** Access method for the content handler. */\n\
						\	public ContentHandler getContentHandler() {\n\
						\		return contentHandler;\n\
						\	}\n\
						\ \n\
						\	/** Access method for the DTD handler. */\n\
						\	public DTDHandler getDTDHandler() {\n\
						\		return dtdHandler;\n\
						\	}\n\
						\ \n\
						\	/** Access method for the entity resolver. */\n\
						\	public EntityResolver getEntityResolver() {\n\
						\		return entityResolver;\n\
						\	}\n\
						\ \n\
						\	/** Access method for the error handler. */\n\
						\	public ErrorHandler getErrorHandler() {\n\
						\		return errorHandler;\n\
						\	}\n\
						\ \n\
						\	/** Check whether or not a feature is set/implemented.\n\
						\ \n\
						\		@param name The name of the feature to check.\n\
						\		@throws SAXNotRecognizedException if the feature is not supported.\n\
						\	*/\n\
						\	public boolean getFeature(String name)\n\
						\	throws SAXNotRecognizedException\n\
						\	{\n\
						\		if (name.equals("http://xml.org/saz/features/namespaces")) {\n\
						\			return feature_namespaces;\n\
						\		} else if (name.equals("http://xml.org/sax/features/namespace-prefixes")) {\n\
						\			return feature_namespace_prefixes;\n\
						\		} else {\n\
						\			throw new SAXNotRecognizedException("");\n\
						\		}\n\
						\	}\n\
						\ \n\
						\	/** Check whether or not a property is set/implemented.\n\
						\ \n\
						\		@param name	The name of the property to check.\n\
						\		@throws SAXNotRecognizedException if the property is not supported.\n\
						\	*/\n\
						\	public Object getProperty(String name)\n\
						\	throws SAXNotRecognizedException\n\
						\	{\n\
						\		throw new SAXNotRecognizedException("");\n\
						\	}\n\
						\ \n\
						\	/** The parser itself.\n\n\
						\		@param source The input to the parser.\n\
						\		@throws SAXException,IOException\n\
						\	*/\n\
						\	public void parse(InputSource source)\n\
						\	throws SAXException, IOException\n\
						\	{\n\
						\		// Buffer the input\n\
						\		BufferedReader input;\n\
						\		// We try to accept as many encodings as possible\n\
						\		String inputEncoding;\n\n\
						\		// Create a BufferedReader from the InputSource\n\
						\		Reader in = source.getCharacterStream();\n\
						\		inputEncoding = source.getEncoding();\n\
						\		if (inputEncoding == null) {\n\
						\			inputEncoding = "UTF-8";\n\
						\		}\n\
						\		if (in == null) {\n\
						\			in = new InputStreamReader(source.getByteStream(), inputEncoding);\n\
						\		}\n\
						\		input = new BufferedReader(in);\n\n\
						\		// Now input is a BufferedReader, actually perform the parse.\n\
						\		{2} parser = new {2}(input);\n\
						\		parser.setParent(this);\n\
						\		contentHandler.startDocument();\n\
						\		while (parser.next_token() != {2}.YYEOF);\n\
						\		contentHandler.endDocument();\n\
						\	}\n\
						\ \n\
						\	/** Alternative form of calling the parser, shorthand for\n\
						\		<code>parse(new InputSource(systemId))</code>\n\
						\ \n\
						\		@param systemId The system identifier used to access the input.\n\
						\	*/\n\
						\	public void parse(String systemId)\n\
						\	throws SAXException, IOException\n\
						\	{\n\
						\		parse(new InputSource(systemId));\n\
						\	}\n\
						\ \n\
						\	/** Setter for the content handler.\n\
						\ \n\
						\		@param handler The new document handler.\n\
						\	*/\n\
						\	public void setContentHandler(ContentHandler handler) {\n\
						\		contentHandler = handler;\n\
						\	}\n\
						\ \n\
						\	/** Accessor for the DTD handler.\n\
						\ \n\
						\		@param handler The new DTD handler.\n\
						\	*/\n\
						\	public void setDTDHandler(DTDHandler handler) {\n\
						\		dtdHandler = handler;\n\
						\	}\n\
						\ \n\
						\	/** Accessor for the entity resolver.\n\
						\ \n\
						\		@param resolver The new entity resolver.\n\
						\	*/\n\
						\	public void setEntityResolver(EntityResolver resolver) {\n\
						\		entityResolver = resolver;\n\
						\	}\n\
						\ \n\
						\	/** Accessor for the error handler.\n\
						\ \n\
						\		@param handler The new error handler.\n\
						\	*/\n\
						\	public void setErrorHandler(ErrorHandler handler) {\n\
						\		errorHandler = handler;\n\
						\	}\n\
						\ \n\
						\	/** Method to set a particular feature.\n\
						\ \n\
						\		@param name		The name of the feature to set.\n\
						\		@param value	The value to assign to the feature.\n\
						\		@throws	SAXNotRecognizedException if the feature is not supported.\n\
						\	*/\n\
						\	public void setFeature(String name, boolean value)\n\
						\	throws SAXNotRecognizedException\n\
						\	{\n\
						\		if (name.equals("http://xml.org/sax/features/namespaces")) {\n\
						\			feature_namespaces = value;\n\
						\		} else if (name.equals("http://xml.org/sax/features/namespace-prefixes")) {\n\
						\			feature_namespace_prefixes = value;\n\
						\		} else {\n\
						\			throw new SAXNotRecognizedException("");\n\
						\		}\n\
						\	}\n\
						\ \n\
						\	/** Method to set a particular property.\n\
						\ \n\
						\		@param name		The name of the property to set.\n\
						\		@param value	The value to assign to the property.\n\
						\		@throws	SAXNotRecognizedException if the property is not supported.\n\
						\	*/\n\
						\	public void setProperty(String name, Object value)\n\
						\	throws SAXNotRecognizedException\n\
						\	{\n\
						\		throw new SAXNotRecognizedException("");\n\
						\	}\n\
						\}\n\
						\ \n
JFLEX_MAIN_TEMPLATE =	\/*\n\
						\	Generated by {0} on {1}\n\
						\*/\n\
						\{13}\n\n\
						\import java.io.Reader;\n\
						\import java.util.Hashtable;\n\
						\import java.util.MissingResourceException;\n\
						\import java.util.ResourceBundle;\n\
						\import java.util.Stack;\n\
						\import java.util.regex.Matcher;\n\
						\import java.util.regex.Pattern;\n\
						\ \n\
						\import org.xml.sax.Attributes;\n\
						\import org.xml.sax.SAXException;\n\
						\import org.xml.sax.XMLReader;\n\
						\import org.xml.sax.helpers.AttributesImpl;\n\
						\ \n\
						\%%\n\
						\%class {2}\n\
						\%int\n\
						\%unicode\n\
						\%function next_token\n\
						\%yylexthrow SAXException\n\
						\%{\n\
						\	/** A reference to the parent SAX2.0 Reader */\n\
						\	private {2}Reader parser;\n\
						\	/** A buffer to hold content until it is ready to be output */\n\
						\	private String contentBuffer;\n\
						\	/** A stack to keep track of nesting. */\n\
						\	private Stack elementStack;\n\
						\	/** A Hashtable to keep track of the namespace->URI mappings. */\n\
						\	private Hashtable namespaceURI;\n\
						\ \n\
						\	/** Provide a reference to the implementation of \n\
						\		<code>Reader</code> that is being used to report\n\
						\		SAX 2.0 events.\n\
						\	*/\n\
						\	public void setParent({2}Reader parent) {\n\
						\		parser = parent;\n\
						\	}\n\
						\ \n\
						\	/** Empty the content buffer and report it \n\
						\		to the DocumentHandler\n\
						\	*/\n\
						\	private void flushContentBuffer()\n\
						\	throws SAXException\n\
						\	{\n\
						\		// Normalise whitespace\n\
						\		contentBuffer = contentBuffer.trim();\n\
						\		if (! contentBuffer.equals("")) {\n\
						\			parser.contentHandler.characters(	\n\
						\												contentBuffer.toCharArray(),\n\
						\												 0,\n\
						\												contentBuffer.length()\n\
						\											 );\n\
						\			contentBuffer = "";\n\
						\		}\n\
						\	}\n\
						\ \n\
						\	private void startElement(String tag, String attlist)\n\
						\	throws SAXException\n\
						\	{\n\
						\		// Handle namespaces if requested.\n\
						\		if (parser.feature_namespaces) {\n\
						\			String namespace;\n\
						\			String name;\n\
						\			int colonIndex = tag.indexOf(''':''');\n\
						\ \n\
						\			// Split the tag into its constituent parts.\n\
						\			if (colonIndex >= 0) {\n\
						\				namespace = tag.substring(0, colonIndex);\n\
						\				name = tag.substring(colonIndex + 1);\n\
						\			} else {\n\
						\				namespace = "";\n\
						\				name = tag;\n\
						\			}\n\
						\ \n\
						\			// Get the URI for this namespace\n\
						\			String nsURI = (String)namespaceURI.get(namespace);\n\
						\			if (nsURI == null) {\n\
						\				throw new SAXException("Unknown namespace prefix: " + namespace);\n\
						\			}\n\
						\ \n\
						\			// Call the endElement event handler\n\
						\			parser.contentHandler.startElement(nsURI, name, tag, processAttlist(attlist, nsURI, name, tag));\n\
						\		} else {\n\
						\			// Call the endElement event handler\n\
						\			parser.contentHandler.startElement(null, null, tag, processAttlist(attlist, null, null, tag));\n\
						\		}\n\
						\	}\n\
						\ \n\
						\	private void endElement(String tag)\n\
						\	throws SAXException\n\
						\	{\n\
						\		// Handle namespaces if requested.\n\
						\		if (parser.feature_namespaces) {\n\
						\			String namespace;\n\
						\			String name;\n\
						\			int colonIndex = tag.indexOf(''':''');\n\
						\ \n\
						\			// Split the tag into its constituent parts.\n\
						\			if (colonIndex >= 0) {\n\
						\				namespace = tag.substring(0, colonIndex);\n\
						\				name = tag.substring(colonIndex + 1);\n\
						\			} else {\n\
						\				namespace = "";\n\
						\				name = tag;\n\
						\			}\n\
						\ \n\
						\			// Get the URI for this namespace\n\
						\			String nsURI = (String)namespaceURI.get(namespace);\n\
						\			if (nsURI == null) {\n\
						\				throw new SAXException("Unknown namespace prefix: " + namespace);\n\
						\			}\n\
						\ \n\
						\			// Call the endElement event handler\n\
						\			parser.contentHandler.endElement(nsURI, name, tag);\n\
						\		} else {\n\
						\			// Call the endElement event handler\n\
						\			parser.contentHandler.endElement(null, null, tag);\n\
						\		}\n\
						\	}\n\
						\ \n\
						\	/** Process a string containing an attribute list and \n\
						\		produce an Attributes representing it.\n\
						\ \n\
						\		@param attlist The <code>String</code> representation\n\
						\						of the attribute list.\n\
						\		@return An <code>Attributes</code> representing the\n\
						\				list of attributes passed in.\n\
						\	*/\n\
						\	private Attributes processAttlist(String attlist, String uri, String localName, String qName)\n\
						\	throws SAXException\n\
						\	{\n\
						\		// Break now if the attribute list supplied is empty\n\
						\		if (attlist.trim().equals("")) {\n\
						\			return null;\n\
						\		}\n\
						\ \n\
						\		// The attribute list to return\n\
						\		AttributesImpl ret = new AttributesImpl();\n\
						\ \n\
						\		// Attribute list scanner\n\
						\		int state = 0;\n\
						\		String name = "";\n\
						\		String value = "";\n\
						\		for (int i = 0; i < attlist.length(); i++) {\n\
						\			char currChar = attlist.charAt(i);\n\
						\			switch (state) {\n\
						\				case 0:\n\
						\					switch (currChar) {\n\
						\						case ''' ''':\n\
						\						case '''\\t''':\n\
						\						case '''\\r''':\n\
						\						case '''\\n''':\n\
						\							// state = 0;\n\
						\							break;\n\
						\						case '''=''':\n\
						\						case '''"''':\n\
						\						case '''\\'''':\n\
						\							throw new SAXException\n\
						\							("Syntax error in attribute list");\n\
						\						default:\n\
						\							name += currChar;\n\
						\							state = 1;\n\
						\					}\n\
						\					break;\n\
						\				case 1:\n\
						\					switch (currChar) {\n\
						\						case ''' ''':\n\
						\						case '''\\t''':\n\
						\						case '''\\r''':\n\
						\						case '''\\n''':\n\
						\							state = 2;\n\
						\							break;\n\
						\						case '''=''':\n\
						\							state = 3;\n\
						\							break;\n\
						\						case '''"''':\n\
						\						case '''\\'''':\n\
						\							throw new SAXException\n\
						\							("Syntax error in attribute list");\n\
						\						default:\n\
						\							name += currChar;\n\
						\							// state = 1;\n\
						\					}\n\
						\					break;\n\
						\				case 2:\n\
						\					switch (currChar) {\n\
						\						case ''' ''':\n\
						\						case '''\\t''':\n\
						\						case '''\\r''':\n\
						\						case '''\\n''':\n\
						\							// state = 2;\n\
						\							break;\n\
						\						case '''=''':\n\
						\							state = 3;\n\
						\							break;\n\
						\						default:\n\
						\							throw new SAXException\n\
						\							("Syntax error in attribute list");\n\
						\					}\n\
						\					break;\n\
						\				case 3:\n\
						\					switch (currChar) {\n\
						\						case ''' ''':\n\
						\						case '''\\t''':\n\
						\						case '''\\r''':\n\
						\						case '''\\n''':\n\
						\							// state = 3;\n\
						\							break;\n\
						\						case '''"''':\n\
						\							state = 4;\n\
						\							break;\n\
						\						case '''\\'''':\n\
						\							state = 6;\n\
						\							break;\n\
						\						default:\n\
						\							throw new SAXException\n\
						\							("Syntax error in attribute list");\n\
						\					}\n\
						\					break;\n\
						\				case 4:\n\
						\					switch (currChar) {\n\
						\						case '''"''':\n\
						\							ret.addAttribute(null, null, name, "CDATA", value);\n\
						\							name = "";\n\
						\							value = "";\n\
						\							state = 5;\n\
						\							break;\n\
						\						default:\n\
						\							value += currChar;\n\
						\							// state = 4;\n\
						\					}\n\
						\					break;\n\
						\				case 5:\n\
						\					switch (currChar) {\n\
						\						case ''' ''':\n\
						\						case '''\\t''':\n\
						\						case '''\\r''':\n\
						\						case '''\\n''':\n\
						\							state = 0;\n\
						\							break;\n\
						\						default:\n\
						\							throw new SAXException\n\
						\							("Syntax error in attribute list");\n\
						\					}\n\
						\					break;\n\
						\				case 6:\n\
						\					switch (currChar) {\n\
						\						case '''\\'''':\n\
						\							ret.addAttribute(null, null, name, "CDATA", value);\n\
						\							name = "";\n\
						\							value = "";\n\
						\							state = 5;\n\
						\							break;\n\
						\						default:\n\
						\							value += currChar;\n\
						\							// state = 6;\n\
						\					}\n\
						\					break;\n\
						\			}\n\
						\		}\n\
						\ \n\
						\		// We''re done.\n\
						\		return ret;\n\
						\	}\n\
						\%}\n\
						\%init{\n\
						\	// Initially the content buffer is empty\n\
						\	contentBuffer = "";\n\
						\	// Create the element stack\n\
						\	elementStack = new Stack();\n\
						\	// Create the namespace->URI hash\n\
						\	namespaceURI = new Hashtable();\n\
						\%init}\n\
						\%%\n\
						\"<?"~"?>"\n\
						\	{\n\
						\		flushContentBuffer();\n\
						\		// Processing instruction\n\
						\ \n\
						\		// XML Spec section 2.6 forbids PITarget tokens\n\
						\		// that match [Xx][Mm][Ll]\n\
						\		if ((yycharat(2) == '''X''' || yycharat(2) == '''x''') &&\n\
						\			(yycharat(3) == '''M''' || yycharat(3) == '''m''') &&\n\
						\			(yycharat(4) == '''L''' || yycharat(4) == '''l'''))\n\
						\		{\n\
						\			// Probably a text or XML declaration\n\
						\			// We ignore those.\n\
						\		} {3}\
						\	}\n\
						\ \n\
						\{4}\n\
						\{5}\n\
						\{6}\n\
						\"<"[^>]*"/>"\n\
						\	{\n\
						\		// Empty element\n\
						\		flushContentBuffer();\n\
						\		String tag = yytext().substring(1, yylength() - 2).trim();\n\
						\		{7}\n\
						\	}\n\
						\ \n\
						\"</"[^>]*">"\n\
						\	{\n\
						\		// End tag\n\
						\		flushContentBuffer();\n\
						\		String tag = yytext().substring(2, yylength() - 1).trim();\n\
						\		String topOfStack = (String)elementStack.peek();\n\
						\		if (elementStack.empty() || ! (topOfStack.equals(tag))) {\n\
						\			throw new SAXException("Well formedness error: </" + tag + "> where </" + topOfStack + "> expected");\n\
						\		} else {\n\
						\			elementStack.pop();\n\
						\		}\n\
						\ \n\
						\		endElement(tag);\n\
						\	}\n\
						\ \n\
						\"<"[^>]*">"\n\
						\	{\n\
						\		// Start tag\n\
						\		flushContentBuffer();\n\
						\		String tag = yytext().substring(1, yylength() - 1).trim();\n\
						\		{8}\n\
						\	}\n\
						\ \n\
						\{9}\n\
						\{10}\n\
						\{11}\n\
						\{12}\n\
						\ \n\
						\[^&<]+\n\
						\	{\n\
						\		// Catch all, treat as content\n\
						\		contentBuffer += yytext();\n\
						\	}\n\
						\ \n\
						\[\\u0000-\\uFFFF]\n\
						\	{\n\
						\		// Really catch all\n\
						\		contentBuffer += yytext();\n\
						\	}\n
PROCESSING_INSTRUCTION_PROCESSOR = \else {\n\
						\			// Get the PI and strip off the <? and ?>\n\
						\			String pi = yytext().substring(2, yylength() - 2).trim();\n\
						\ \n\
						\			// Find the index of the first whitespace character\n\
						\			int fWI = -1;\n\
						\			for (int i = 0; i < pi.length(); i++) {\n\
						\				if (Character.isWhitespace(pi.charAt(i))) {\n\
						\					fWI = i;\n\
						\					break;\n\
						\				}\n\
						\			}\n\
						\ \n\
						\			// Get the target and data\n\
						\			String target = null;\n\
						\			String data = null;\n\
						\			if (fWI >= 0) {\n\
						\				// Looks like there's a target AND data\n\
						\				target = pi.substring(0, fWI);\n\
						\				data = pi.substring(fWI);\n\
						\			} else {\n\
						\				// Target only by the looks of things.\n\
						\				target = pi;\n\
						\			}\n\
						\			parser.contentHandler.processingInstruction(target, data);\n\
						\		}\n
COMMENT_PROCESSOR = 	\"<!--"~"-->"\n\
						\	{\n\
						\		// Comment, ignore.\n\
						\	}\n
DOCTYPEDECL_PROCESSOR = \"<!DOCTYPE"~">"\n\
						\	{\n\
						\		// Document type declaration and internal subset, ignore.\n\
						\	}\n
CDSECT_PROCESSOR =		\"<![CDATA["~"]]>"\n\
						\	{\n\
						\		// CData section, everything goes into the content buffer\n\
						\		contentBuffer += yytext().substring(9, yylength() - 3);\n\
						\	}\n
START_TAG_ATTLIST =		\String elementName;\n\
						\		String attlist = null;\n\
						\		\n\
						\		// Find the first whitespace character\n\
						\		int fWI = -1;\n\
						\		for (int i = 0; i < tag.length(); i++) {\n\
						\			if (Character.isWhitespace(tag.charAt(i))) {\n\
						\				fWI = i;\n\
						\				break;\n\
						\			}\n\
						\		}\n\
						\		\n\
						\		// Detect whether or not there's an attribute list\n\
						\		// and strip out the element name\n\
						\		if (fWI >= 0) {\n\
						\			elementName = tag.substring(0, fWI);\n\
						\			\n\
						\			attlist = tag.substring(fWI);\n\
						\		} else {\n\
						\			elementName = tag;\n\
						\		}\n\
						\		\n\
						\		startElement(elementName, attlist);\n\
						\		elementStack.push(elementName);\n
EMPTY_TAG_ATTLIST =		\String elementName;\n\
						\		String attlist = null;\n\
						\		\n\
						\		// Find the first whitespace character\n\
						\		int fWI = -1;\n\
						\		for (int i = 0; i < tag.length(); i++) {\n\
						\			if (Character.isWhitespace(tag.charAt(i))) {\n\
						\				fWI = i;\n\
						\				break;\n\
						\			}\n\
						\		}\n\
						\		\n\
						\		// Detect whether or not there's an attribute list\n\
						\		// and strip out the element name\n\
						\		if (fWI >= 0) {\n\
						\			elementName = tag.substring(0, fWI);\n\
						\			\n\
						\			// Process the attribute list\n\
						\			attlist = tag.substring(fWI);\n\
						\		} else {\n\
						\			elementName = tag;\n\
						\		}\n\
						\		\n\
						\		startElement(elementName, attlist);\n\
						\		endElement(elementName);\n
START_TAG_NO_ATTLIST =	\		startElement(tag, null);\n\
						\		elementStack.push(tag);\n
EMPTY_TAG_NO_ATTLIST =	\		startElement(tag, null);\n\
						\		endElement(tag);\n
PREDEFINED_ENTITIES =	\// Predefined entities\n\
						\"&amp;" { contentBuffer += "&"; }\n\
						\"&lt;" { contentBuffer += "<"; }\n\
						\"&gt;" { contentBuffer += ">"; }\n\
						\"&apos;" { contentBuffer += "'"; }\n\
						\"&quot;" { contentBuffer += "\\""; }\n\
						\ \n
CHAR_REF_RESOLVER =		\"&#"[^;]+";"\n\
						\	{ \n\
						\		// Character reference, resolve and add to the content buffer.\n\
						\		String ref = yytext().substring(2, yylength() - 1);\n\
						\		if (ref.startsWith("x")) {\n\
						\			ref = ref.substring(1);\n\
						\			contentBuffer += (char)Integer.parseInt(ref, 16);\n\
						\		} else {\n\
						\			contentBuffer += (char)Integer.parseInt(ref, 10);\n\
						\		}\n\
						\	}\n\
						\ \n
INTERNAL_ENT_RESOLVER =	\"&"~";"\n\
						\	{\n\
						\		// Internal Entity Reference\n\
						\		try {\n\
						\			contentBuffer += ResourceBundle.getBundle("entities").getString(yytext());\n\
						\		} catch (MissingResourceException e) {\n\
						\			// Undefined internal entity\n\
						\			// Just add it to the content buffer\n\
						\			contentBuffer += yytext();\n\
						\		}\n\
						\	}\n
INT_ENT_PROP_TEXT_FMT =	\	&{0}; = {1}\n
EXT_ENT_PROP_TEXT_FMT = \	"&{0};"\n\
						\		{\n\
						\			// External parsed entity\n\
						\			InputSource entityIn = parser.entityResolver.resolveEntity({1}, {2});\n\
						\			Reader in = entityIn.getCharacterStream();\n\
						\			if (in == null) {\n\
						\				in = new InputStreamReader(entityIn.getByteStream(), entityIn.getEncoding());\n\
						\			}\n\
						\			yypushstream(in);\n\
						\		}\n\n
BUILD_MAIN_TEMPLATE =	\<?xml version="1.0"?>\n\
						\<!--\n\
						\	Generated by {0} on {1}\n\
						\-->\n\
						\ \n\
						\<project name="{2}" default="jar" basedir=".">\n\
						\	<taskdef name="jflex" classname="JFlex.anttask.JFlexTask" />\n\
						\ \n\
						\	<target name="build" depends="runjflex">\n\
						\		<javac srcdir="." />\n\
						\	</target>\n\
						\	<target name="runjflex">\n\
						\		<jflex file="{2}.jflex" />\n\
						\	</target>\n\
						\	<target name="jar" depends="build">\n\
						\		<jar destfile="{2}.jar" basedir="." includes="*.class,*.properties" />\n\
						\	</target>\n\
						\	<target name="clean">\n\
						\		<delete file="{2}.java" />\n\
						\		<delete>\n\
						\			<fileset dir="." includes="*.class,*.jar" />\n\
						\		</delete>\n\
						\	</target>\n\
						\</project>\n
ENTITIES_MAIN_TEMPLATE =\# Generated by {0} on {1}\n\
						\{2}
