// vim:filetype=javacup:ts=4
/*
	Copyright (c) 2003-2006
	Conor McDermottroe.  All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:
	1. Redistributions of source code must retain the above copyright
	   notice, this list of conditions and the following disclaimer.
	2. Redistributions in binary form must reproduce the above copyright
	   notice, this list of conditions and the following disclaimer in the
	   documentation and/or other materials provided with the distribution.
	3. Neither the name of the author nor the names of any contributors to
	   the software may be used to endorse or promote products derived from
	   this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
	TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
	OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.Symbol;

import com.mcdermottroe.exemplar.Constants;
import com.mcdermottroe.exemplar.DBC;
import com.mcdermottroe.exemplar.input.InputModule;
import com.mcdermottroe.exemplar.input.ParserException;
import com.mcdermottroe.exemplar.model.XMLAlternative;
import com.mcdermottroe.exemplar.model.XMLAttribute;
import com.mcdermottroe.exemplar.model.XMLAttributeList;
import com.mcdermottroe.exemplar.model.XMLContent;
import com.mcdermottroe.exemplar.model.XMLDocumentType;
import com.mcdermottroe.exemplar.model.XMLElement;
import com.mcdermottroe.exemplar.model.XMLElementReference;
import com.mcdermottroe.exemplar.model.XMLEntity;
import com.mcdermottroe.exemplar.model.XMLExternalIdentifier;
import com.mcdermottroe.exemplar.model.XMLMarkupDeclaration;
import com.mcdermottroe.exemplar.model.XMLMixedContent;
import com.mcdermottroe.exemplar.model.XMLNotation;
import com.mcdermottroe.exemplar.model.XMLObject;
import com.mcdermottroe.exemplar.model.XMLSequence;
import com.mcdermottroe.exemplar.ui.Message;
import com.mcdermottroe.exemplar.ui.Options;

parser code {:
	/** Implementation of {@link InputModule#parse(String)}.

		@param dtdFile			The path to the file to parse from.
		@return					An {@link XMLDocumentType} representing the
								vocabulary described by the DTD at
								<code>dtdFile</code>.
		@throws	ParserException if {@link #parse(File)} throws one.
	*/
	public XMLDocumentType parse(String dtdFile)
	throws ParserException
	{
		if ("-".equals(dtdFile)) {
			return parse(System.in, new File(Constants.CWD));
		}
		return parse(new File(dtdFile));
	}

	/** Implementation of {@link InputModule#parse(File)}.

		@param dtdFile			The file to parse from.
		@return					An {@link XMLDocumentType} representing the
								vocabulary described by the DTD at
								<code>dtdFile</code>.
		@throws	ParserException if {@link #parse(File)} throws one.
	*/
	public XMLDocumentType parse(File dtdFile)
	throws ParserException
	{
		try {
			return parse(new FileInputStream(dtdFile), dtdFile.getParentFile());
		} catch (FileNotFoundException e) {
			throw new ParserException(
				Message.DTDLEXER_INPUT_NOT_FOUND(dtdFile.getAbsolutePath()),
				e
			);
		}
	}

	/** Implementation of {@link InputModule#parse(InputStream)}.

		@param dtdSource		The input source to parse from.
		@return					An {@link XMLDocumentType} representing the
								vocabulary described by the DTD at
								<code>dtdFile</code>.
		@throws	ParserException if {@link #parse(File)} throws one.
	*/
	public XMLDocumentType parse(InputStream dtdSource)
	throws ParserException
	{
		return parse(dtdSource, new File(Constants.CWD));
	}


	/** Workhorse for {@link #parse(String)}, {@link #parse(File)} and {@link
		#parse(InputStream)}.

		@param input			The input source providing the DTD text.
		@param baseDir			A directory to use when converting relative
								paths in the DTD into absolute paths.
		@return					An {@link XMLDocumentType} representing the
								vocabulary described by the DTD at
								<code>dtdFile</code>.
		@throws ParserException	if the lexer can't find the input file
	*/
	private XMLDocumentType parse(InputStream input, File baseDir)
	throws ParserException
	{
		DBC.REQUIRE(input != null);
		DBC.REQUIRE(baseDir != null);

		// Set the symbol factory
		symbolFactory = new ComplexSymbolFactory();

		// Create the lexer and set it as the scanner.
		Lexer lex = new Lexer(input);
		lex.setDtdPath(baseDir.getAbsolutePath());
		setScanner(lex);

		// Actually go and do the parse.
		try {
			return (XMLDocumentType)((Symbol)parse()).value;
		} catch (Exception e) {
			throw new ParserException(Message.DTDPARSER_THREW_EXCEPTION, e);
		}
	}

	/** {@inheritDoc} */
	public String toString() {
		return "The input file is a DTD.";
	}
:}

terminal String	ATTLIST_HEAD;
terminal String	ELEMENT_HEAD;
terminal String	ENTITY_HEAD;
terminal String NOTATION_HEAD;
terminal String	HASH_PCDATA;
terminal String	HASH_FIXED;
terminal String	HASH_IMPLIED;
terminal String	HASH_REQUIRED;
terminal String	CDATA;
terminal String	SYSTEM;
terminal String	PUBLIC;
terminal String	NDATA_SURROUNDED_BY_S;
terminal String	NOTATION;
terminal String	EMPTY;
terminal String	ANY;
terminal String	ID;
terminal String	IDREF;
terminal String	IDREFS;
terminal String	ENTITY;
terminal String	ENTITIES;
terminal String	NMTOKEN;
terminal String	NMTOKENS;
terminal String	S;
terminal String	AMP;
terminal String	APOS;
terminal String	AT;
terminal String	BACKTICK;
terminal String	BASECHAR;
terminal String	BSLASH;
terminal String	CARAT;
terminal String	CHAR;
terminal String	CHARREF;
terminal String	COLON;
terminal String	COMBININGCHAR;
terminal String	COMMA;
terminal String	COMMA_PRECEDED_BY_S;
terminal String	COMMA_FOLLOWED_BY_S;
terminal String	COMMA_SURROUNDED_BY_S;
terminal String	COMMENT;
terminal String	DIGIT;
terminal String	DOLLAR;
terminal String	DOT;
terminal String	EQUALS;
terminal String	EXCLAM;
terminal String	EXTENDER;
terminal String	GT;
terminal String	HASH;
terminal String	IDEOGRAPHIC;
terminal String	LBRACE;
terminal String	LPAREN;
terminal String	LSQUARE;
terminal String	LT;
terminal String	MINUS;
terminal String	PERCENT;
terminal String	PIPE;
terminal String	PIPE_PRECEDED_BY_S;
terminal String	PIPE_FOLLOWED_BY_S;
terminal String	PIPE_SURROUNDED_BY_S;
terminal String	PLUS;
terminal String	QMARK;
terminal String	QUOT;
terminal String	RBRACE;
terminal String	RPAREN;
terminal String	RSQUARE;
terminal String	SEMI;
terminal String	SLASH;
terminal String	STAR;
terminal String	TILDE;
terminal String	UNDERSCORE;

non terminal XMLAttribute				AttDef;
non terminal XMLAttributeList			AttDef_STAR;
non terminal XMLAttributeList			AttlistDecl;
non terminal XMLAttribute				AttType;
non terminal String						AttValue;
non terminal String						AttValue_QUOT_STRING;
non terminal String						AttValue_QUOT_STRING_CHAR;
non terminal String						AttValue_APOS_STRING;
non terminal String						AttValue_APOS_STRING_CHAR;
non terminal String						Char_NO_QUOT;
non terminal String						Char_NO_QUOT_STAR;
non terminal String						Char_NO_APOS;
non terminal String						Char_NO_APOS_STAR;
non terminal XMLSequence				children;
non terminal XMLAlternative				choice;
non terminal XMLAlternative				choice_cpLIST;
non terminal String						COMMA_SURROUNDED_BY_OPT_S;
non terminal XMLElement					contentspec;
non terminal XMLSequence				cp;
non terminal String						DeclSep;
non terminal XMLAttribute				DefaultDecl;
non terminal XMLElement					elementdecl;
non terminal XMLEntity					EntityDecl;
non terminal XMLEntity					EntityDef;
non terminal String						EntityRef;
non terminal String						EntityValue;
non terminal String						EntityValue_QUOT_STRING;
non terminal String						EntityValue_QUOT_STRING_CHAR;
non terminal String						EntityValue_APOS_STRING;
non terminal String						EntityValue_APOS_STRING_CHAR;
non terminal XMLAttribute				Enumeration;
non terminal List						Enumeration_NmtokenLIST;
non terminal XMLAttribute				EnumeratedType;
non terminal XMLExternalIdentifier		ExternalID;
non terminal XMLDocumentType			extSubset;
non terminal List						extSubsetDecl;
non terminal XMLEntity					GEDecl;
non terminal String						GT_PRECEDED_BY_OPT_S;
non terminal String						LPAREN_FOLLOWED_BY_OPT_S;
non terminal XMLMarkupDeclaration		markupDecl;
non terminal XMLMixedContent			Mixed;
non terminal XMLMixedContent			Mixed_NameLIST;
non terminal String						Name;
non terminal String						NameChar;
non terminal String						NameChar_STAR;
non terminal String						NameStartChar;
non terminal String						NDataDecl;
non terminal String						Nmtoken;
non terminal XMLNotation				NotationDecl;
non terminal XMLAttribute				NotationType;
non terminal List						NotationType_NameLIST;
non terminal String						PIPE_SURROUNDED_WITH_OPT_S;
non terminal String						PubidLiteral;
non terminal String						PublicID;
non terminal String						Reference;
non terminal String						RPAREN_PRECEDED_BY_OPT_S;
non terminal String						s;
non terminal XMLSequence				seq;
non terminal XMLSequence				seq_cpLIST;
non terminal XMLAttribute				StringType;
non terminal String						SystemLiteral;
non terminal XMLAttribute				TokenizedType;

precedence nonassoc BASECHAR, COLON, COMBININGCHAR, DIGIT, DOT, EXTENDER, IDEOGRAPHIC, MINUS, S, UNDERSCORE;

start with extSubset;

// Page 24
AttDef							::= s Name:name s AttType:attribute s DefaultDecl:defaultDecl
										{:
											DBC.ASSERT(attribute instanceof XMLAttribute);
											DBC.ASSERT(defaultDecl instanceof XMLAttribute);
											((XMLAttribute)attribute).setName(name.toString());
											((XMLAttribute)attribute).setDefaultDecl((XMLAttribute)defaultDecl);
											RESULT = attribute;
										:};
// AttDef*
AttDef_STAR						::= /* ε */
										{:
											RESULT = new XMLAttributeList();
										:} |
									AttDef_STAR:attlist AttDef:attdef
										{:
											DBC.ASSERT(attlist instanceof XMLAttributeList);
											DBC.ASSERT(attdef instanceof XMLAttribute);
											((XMLAttributeList)attlist).addAttribute((XMLAttribute)attdef);
											RESULT = attlist;
										:};
// Page 24
AttlistDecl						::=	ATTLIST_HEAD s Name:name AttDef_STAR:attlist GT_PRECEDED_BY_OPT_S
										{:
											DBC.ASSERT(attlist instanceof XMLAttributeList);
											((XMLAttributeList)attlist).setName(name.toString());
											RESULT = attlist;
										:};
// Page 25
AttType							::=	StringType:attribute
										{:
											RESULT = attribute;
										:} |
									TokenizedType:attribute
										{:
											RESULT = attribute;
										:} |
									EnumeratedType:attribute
										{:
											RESULT = attribute;
										:};
// Page 9
AttValue						::= QUOT AttValue_QUOT_STRING:value QUOT
										{:
											RESULT = value;
										:} |
									APOS AttValue_APOS_STRING:value APOS
										{:
											RESULT = value;
										:};
// A string of the characters allowed between quote marks in an AttValue production
AttValue_QUOT_STRING			::= /* ε */
										{:
											RESULT = "";
										:} |
									AttValue_QUOT_STRING:a AttValue_QUOT_STRING_CHAR:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									AttValue_QUOT_STRING:a Reference:b
										{:
											RESULT = a.toString() + b.toString();
										:};
// The characters allowed between quote marks in an AttValue production
AttValue_QUOT_STRING_CHAR		::= CHAR:value
										{:
											RESULT = value;
										:} |
									APOS:value
										{:
											RESULT = value;
										:} |
									AT:value
										{:
											RESULT = value;
										:} |
									BACKTICK:value
										{:
											RESULT = value;
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH:value
										{:
											RESULT = value;
										:} |
									CARAT:value
										{:
											RESULT = value;
										:} |
									COLON:value
										{:
											RESULT = value;
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA:value
										{:
											RESULT = value;
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR:value
										{:
											RESULT = value;
										:} |
									DOT:value
										{:
											RESULT = value;
										:} |
									EQUALS:value
										{:
											RESULT = value;
										:} |
									EXCLAM:value
										{:
											RESULT = value;
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT:value
										{:
											RESULT = value;
										:} |
									HASH:value
										{:
											RESULT = value;
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE:value
										{:
											RESULT = value;
										:} |
									LPAREN:value
										{:
											RESULT = value;
										:} |
									LSQUARE:value
										{:
											RESULT = value;
										:} |
									MINUS:value
										{:
											RESULT = value;
										:} |
									PERCENT:value
										{:
											RESULT = value;
										:} |
									PLUS:value
										{:
											RESULT = value;
										:} |
									QMARK:value
										{:
											RESULT = value;
										:} |
									RBRACE:value
										{:
											RESULT = value;
										:} |
									RPAREN:value
										{:
											RESULT = value;
										:} |
									RSQUARE:value
										{:
											RESULT = value;
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI:value
										{:
											RESULT = value;
										:} |
									SLASH:value
										{:
											RESULT = value;
										:} |
									STAR:value
										{:
											RESULT = value;
										:} |
									TILDE:value
										{:
											RESULT = value;
										:} |
									UNDERSCORE:value
										{:
											RESULT = value;
										:} |
									HASH_PCDATA:value
										{:
											RESULT = value;
										:} |
									HASH_FIXED:value
										{:
											RESULT = value;
										:} |
									HASH_IMPLIED:value
										{:
											RESULT = value;
										:} |
									HASH_REQUIRED:value
										{:
											RESULT = value;
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NDATA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:} |
									COMMA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:};
// A string of the characters allowed between apostrophes in an AttValue production
AttValue_APOS_STRING			::= /* ε */
										{:
											RESULT = "";
										:} |
									AttValue_APOS_STRING:a AttValue_APOS_STRING_CHAR:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									AttValue_APOS_STRING:a Reference:b
										{:
											RESULT = a.toString() + b.toString();
										:};
// The characters allowed between apostrophes in an AttValue production
AttValue_APOS_STRING_CHAR		::= CHAR:value
										{:
											RESULT = value;
										:} |
									AT:value
										{:
											RESULT = value;
										:} |
									BACKTICK:value
										{:
											RESULT = value;
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH:value
										{:
											RESULT = value;
										:} |
									CARAT:value
										{:
											RESULT = value;
										:} |
									COLON:value
										{:
											RESULT = value;
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA
										{:
											RESULT = ",";
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR
										{:
											RESULT = "$";
										:} |
									DOT
										{:
											RESULT = ".";
										:} |
									EQUALS
										{:
											RESULT = "=";
										:} |
									EXCLAM
										{:
											RESULT = "!";
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT
										{:
											RESULT = ">";
										:} |
									HASH
										{:
											RESULT = "#";
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE
										{:
											RESULT = "{";
										:} |
									LPAREN
										{:
											RESULT = "(";
										:} |
									LSQUARE
										{:
											RESULT = "[";
										:} |
									MINUS
										{:
											RESULT = "-";
										:} |
									PERCENT
										{:
											RESULT = "%";
										:} |
									PLUS
										{:
											RESULT = "+";
										:} |
									QMARK
										{:
											RESULT = "?";
										:} |
									QUOT
										{:
											RESULT = "\"";
										:} |
									RBRACE
										{:
											RESULT = "}";
										:} |
									RPAREN
										{:
											RESULT = ")";
										:} |
									RSQUARE
										{:
											RESULT = "]";
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI
										{:
											RESULT = ";";
										:} |
									SLASH
										{:
											RESULT = "/";
										:} |
									STAR
										{:
											RESULT = "*";
										:} |
									TILDE:value
										{:
											RESULT = value;
										:} |
									UNDERSCORE:value
										{:
											RESULT = value;
										:} |
									HASH_PCDATA:value
										{:
											RESULT = value;
										:} |
									HASH_FIXED:value
										{:
											RESULT = value;
										:} |
									HASH_IMPLIED:value
										{:
											RESULT = value;
										:} |
									HASH_REQUIRED:value
										{:
											RESULT = value;
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NDATA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:} |
									COMMA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:};
// Char - '"'
Char_NO_QUOT					::= CHAR:value
										{:
											RESULT = value;
										:} |
									AMP
										{:
											RESULT = "&";
										:} |
									APOS
										{:
											RESULT = "'";
										:} |
									AT
										{:
											RESULT = "@";
										:} |
									BACKTICK
										{:
											RESULT = "`";
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH
										{:
											RESULT = "\\";
										:} |
									CARAT
										{:
											RESULT = "^";
										:} |
									COLON
										{:
											RESULT = ":";
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA
										{:
											RESULT = ",";
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR
										{:
											RESULT = "$";
										:} |
									DOT
										{:
											RESULT = ".";
										:} |
									EQUALS
										{:
											RESULT = "=";
										:} |
									EXCLAM
										{:
											RESULT = "!";
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT
										{:
											RESULT = ">";
										:} |
									HASH
										{:
											RESULT = "#";
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE
										{:
											RESULT = "{";
										:} |
									LPAREN
										{:
											RESULT = "(";
										:} |
									LSQUARE
										{:
											RESULT = "[";
										:} |
									LT
										{:
											RESULT = "<";
										:} |
									MINUS
										{:
											RESULT = "-";
										:} |
									PERCENT
										{:
											RESULT = "%";
										:} |
									PLUS
										{:
											RESULT = "+";
										:} |
									QMARK
										{:
											RESULT = "?";
										:} |
									RBRACE
										{:
											RESULT = "}";
										:} |
									RPAREN
										{:
											RESULT = ")";
										:} |
									RSQUARE
										{:
											RESULT = "]";
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI
										{:
											RESULT = ";";
										:} |
									SLASH
										{:
											RESULT = "/";
										:} |
									STAR
										{:
											RESULT = "*";
										:} |
									TILDE
										{:
											RESULT = "~";
										:} |
									UNDERSCORE
										{:
											RESULT = "_";
										:};
// Char_NO_QUOT*
Char_NO_QUOT_STAR				::=	/* ε */
										{:
											RESULT = "";
										:} |
									Char_NO_QUOT_STAR:a Char_NO_QUOT:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_QUOT_STAR:a HASH_PCDATA
										{:
											RESULT = a.toString() + "#PCDATA";
										:} |
									Char_NO_QUOT_STAR:a HASH_FIXED
										{:
											RESULT = a.toString() + "#FIXED";
										:} |
									Char_NO_QUOT_STAR:a HASH_IMPLIED
										{:
											RESULT = a.toString() + "#IMPLIED";
										:} |
									Char_NO_QUOT_STAR:a HASH_REQUIRED
										{:
											RESULT = a.toString() + "#REQUIRED";
										:} |
									Char_NO_QUOT_STAR:a CDATA:cdata
										{:
											RESULT = a.toString() + cdata;
										:} |
									Char_NO_QUOT_STAR:a SYSTEM:system
										{:
											RESULT = a.toString() + system;
										:} |
									Char_NO_QUOT_STAR:a PUBLIC:pub
										{:
											RESULT = a.toString() + pub;
										:} |
									Char_NO_QUOT_STAR:a NDATA_SURROUNDED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_QUOT_STAR:a NOTATION
										{:
											RESULT = a.toString() + "NOTATION";
										:} |
									Char_NO_QUOT_STAR:a EMPTY
										{:
											RESULT = a.toString() + "EMPTY";
										:} |
									Char_NO_QUOT_STAR:a ANY
										{:
											RESULT = a.toString() + "ANY";
										:} |
									Char_NO_QUOT_STAR:a ID:id
										{:
											RESULT = a.toString() + id;
										:} |
									Char_NO_QUOT_STAR:a IDREF:idref
										{:
											RESULT = a.toString() + idref;
										:} |
									Char_NO_QUOT_STAR:a IDREFS:idrefs
										{:
											RESULT = a.toString() + idrefs;
										:} |
									Char_NO_QUOT_STAR:a ENTITY:entity
										{:
											RESULT = a.toString() + entity;
										:} |
									Char_NO_QUOT_STAR:a ENTITIES:entities
										{:
											RESULT = a.toString() + entities;
										:} |
									Char_NO_QUOT_STAR:a NMTOKEN:nmtoken
										{:
											RESULT = a.toString() + nmtoken;
										:} |
									Char_NO_QUOT_STAR:a NMTOKENS:nmtokens
										{:
											RESULT = a.toString() + nmtokens;
										:} |
									Char_NO_QUOT_STAR:a COMMA_SURROUNDED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_QUOT_STAR:a COMMA_PRECEDED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_QUOT_STAR:a COMMA_FOLLOWED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_QUOT_STAR:a PIPE_SURROUNDED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_QUOT_STAR:a PIPE_PRECEDED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_QUOT_STAR:a PIPE_FOLLOWED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:};
// Char - "'"
Char_NO_APOS					::= CHAR:value
										{:
											RESULT = value;
										:} |
									AMP
										{:
											RESULT = "&";
										:} |
									AT
										{:
											RESULT = "@";
										:} |
									BACKTICK
										{:
											RESULT = "`";
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH
										{:
											RESULT = "\\";
										:} |
									CARAT
										{:
											RESULT = "^";
										:} |
									COLON
										{:
											RESULT = ":";
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA
										{:
											RESULT = ",";
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR
										{:
											RESULT = "$";
										:} |
									DOT
										{:
											RESULT = ".";
										:} |
									EQUALS
										{:
											RESULT = "=";
										:} |
									EXCLAM
										{:
											RESULT = "!";
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT
										{:
											RESULT = ">";
										:} |
									HASH
										{:
											RESULT = "#";
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE
										{:
											RESULT = "{";
										:} |
									LPAREN
										{:
											RESULT = "(";
										:} |
									LSQUARE
										{:
											RESULT = "[";
										:} |
									LT
										{:
											RESULT = "<";
										:} |
									MINUS
										{:
											RESULT = "-";
										:} |
									PERCENT
										{:
											RESULT = "%";
										:} |
									PLUS
										{:
											RESULT = "+";
										:} |
									QMARK
										{:
											RESULT = "?";
										:} |
									QUOT
										{:
											RESULT = "\"";
										:} |
									RBRACE
										{:
											RESULT = "}";
										:} |
									RPAREN
										{:
											RESULT = ")";
										:} |
									RSQUARE
										{:
											RESULT = "]";
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI
										{:
											RESULT = ";";
										:} |
									SLASH
										{:
											RESULT = "/";
										:} |
									STAR
										{:
											RESULT = "*";
										:} |
									TILDE
										{:
											RESULT = "~";
										:} |
									UNDERSCORE
										{:
											RESULT = "_";
										:};
// Char_NO_APOS*
Char_NO_APOS_STAR				::=	/* ε */
										{:
											RESULT = "";
										:} |
									Char_NO_APOS_STAR:a Char_NO_APOS:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_APOS_STAR:a HASH_PCDATA
										{:
											RESULT = a.toString() + "#PCDATA";
										:} |
									Char_NO_APOS_STAR:a HASH_FIXED
										{:
											RESULT = a.toString() + "#FIXED";
										:} |
									Char_NO_APOS_STAR:a HASH_IMPLIED
										{:
											RESULT = a.toString() + "#IMPLIED";
										:} |
									Char_NO_APOS_STAR:a HASH_REQUIRED
										{:
											RESULT = a.toString() + "#REQUIRED";
										:} |
									Char_NO_APOS_STAR:a CDATA:b
										{:
											RESULT = a.toString() + b;
										:} |
									Char_NO_APOS_STAR:a SYSTEM:b
										{:
											RESULT = a.toString() + b;
										:} |
									Char_NO_APOS_STAR:a PUBLIC:b
										{:
											RESULT = a.toString() + b;
										:} |
									Char_NO_APOS_STAR:a NDATA_SURROUNDED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_APOS_STAR:a NOTATION
										{:
											RESULT = a.toString() + "NOTATION";
										:} |
									Char_NO_APOS_STAR:a EMPTY
										{:
											RESULT = a.toString() + "EMPTY";
										:} |
									Char_NO_APOS_STAR:a ANY
										{:
											RESULT = a.toString() + "ANY";
										:} |
									Char_NO_APOS_STAR:a ID:b
										{:
											RESULT = a.toString() + b;
										:} |
									Char_NO_APOS_STAR:a IDREF:b
										{:
											RESULT = a.toString() + b;
										:} |
									Char_NO_APOS_STAR:a IDREFS:b
										{:
											RESULT = a.toString() + b;
										:} |
									Char_NO_APOS_STAR:a ENTITY:b
										{:
											RESULT = a.toString() + b;
										:} |
									Char_NO_APOS_STAR:a ENTITIES:b
										{:
											RESULT = a.toString() + b;
										:} |
									Char_NO_APOS_STAR:a NMTOKEN:b
										{:
											RESULT = a.toString() + b;
										:} |
									Char_NO_APOS_STAR:a NMTOKENS:b
										{:
											RESULT = a.toString() + b;
										:} |
									Char_NO_APOS_STAR:a COMMA_SURROUNDED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_APOS_STAR:a COMMA_PRECEDED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_APOS_STAR:a COMMA_FOLLOWED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_APOS_STAR:a PIPE_SURROUNDED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_APOS_STAR:a PIPE_PRECEDED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									Char_NO_APOS_STAR:a PIPE_FOLLOWED_BY_S:b
										{:
											RESULT = a.toString() + b.toString();
										:};
// Page 22
children						::= choice:c
										{:
											DBC.ASSERT(c instanceof XMLAlternative);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLAlternative)c);
											((XMLSequence)RESULT).setMinMaxOccurs(1, 1);
										:} |
									choice:c QMARK
										{:
											DBC.ASSERT(c instanceof XMLAlternative);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLAlternative)c);
											((XMLSequence)RESULT).setMinMaxOccurs(0, 1);
										:} |
									choice:c STAR
										{:
											DBC.ASSERT(c instanceof XMLAlternative);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLAlternative)c);
											((XMLSequence)RESULT).setMinMaxOccurs(0, Constants.INFINITY);
										:} |
									choice:c PLUS
										{:
											DBC.ASSERT(c instanceof XMLAlternative);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLAlternative)c);
											((XMLSequence)RESULT).setMinMaxOccurs(1, Constants.INFINITY);
										:} |
									seq:s
										{:
											DBC.ASSERT(s instanceof XMLSequence);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLSequence)s);
											((XMLSequence)RESULT).setMinMaxOccurs(1, 1);
										:} |
									seq:s QMARK
										{:
											DBC.ASSERT(s instanceof XMLSequence);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLSequence)s);
											((XMLSequence)RESULT).setMinMaxOccurs(0, 1);
										:} |
									seq:s STAR
										{:
											DBC.ASSERT(s instanceof XMLSequence);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLSequence)s);
											((XMLSequence)RESULT).setMinMaxOccurs(0, Constants.INFINITY);
										:} |
									seq:s PLUS
										{:
											DBC.ASSERT(s instanceof XMLSequence);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLSequence)s);
											((XMLSequence)RESULT).setMinMaxOccurs(1, Constants.INFINITY);
										:};
// Page 22
choice							::= LPAREN_FOLLOWED_BY_OPT_S cp:a PIPE_SURROUNDED_WITH_OPT_S cp:b RPAREN_PRECEDED_BY_OPT_S
										{:
											DBC.ASSERT(a instanceof XMLObject);
											DBC.ASSERT(b instanceof XMLObject);
											RESULT = new XMLAlternative();
											((XMLAlternative)RESULT).addObject((XMLObject)a);
											((XMLAlternative)RESULT).addObject((XMLObject)b);
										:} |
									LPAREN_FOLLOWED_BY_OPT_S cp:a PIPE_SURROUNDED_WITH_OPT_S cp:b choice_cpLIST:c RPAREN_PRECEDED_BY_OPT_S
										{:
											DBC.ASSERT(a instanceof XMLObject);
											DBC.ASSERT(b instanceof XMLObject);
											DBC.ASSERT(c instanceof XMLObject);
											RESULT = new XMLAlternative();
											((XMLAlternative)RESULT).addObject((XMLObject)a);
											((XMLAlternative)RESULT).addObject((XMLObject)b);
											((XMLAlternative)RESULT).append((XMLObject)c);
										:};
// (S? '|' S? cp)+
choice_cpLIST					::= PIPE_SURROUNDED_WITH_OPT_S cp:cp
										{:
											DBC.ASSERT(cp instanceof XMLObject);
											RESULT = new XMLAlternative();
											((XMLAlternative)RESULT).addObject((XMLObject)cp);
										:} |
									choice_cpLIST:cpList PIPE_SURROUNDED_WITH_OPT_S cp:cp
										{:
											DBC.ASSERT(cp instanceof XMLObject);
											RESULT = cpList;
											((XMLAlternative)RESULT).addObject((XMLObject)cp);
										:};
// S? ',' S?
COMMA_SURROUNDED_BY_OPT_S		::= COMMA
										{:
											RESULT = ",";
										:} |
									COMMA_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:};
// Page 21
contentspec						::= EMPTY
										{:
											RESULT = new XMLElement(XMLElement.ContentType.EMPTY);
										:} |
									ANY
										{:
											RESULT = new XMLElement(XMLElement.ContentType.ANY);
										:} |
									Mixed:mixed
										{:
											DBC.ASSERT(mixed instanceof XMLMixedContent);
											RESULT = new XMLElement((XMLMixedContent)mixed);
										:} |
									children:sequence
										{:
											DBC.ASSERT(sequence instanceof XMLSequence);
											RESULT = new XMLElement((XMLSequence)sequence);
										:};
// Page 22
cp								::= Name:name
										{:
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject(new XMLElementReference(name.toString()));
											((XMLSequence)RESULT).setMinMaxOccurs(1, 1);
										:} |
									Name:name QMARK
										{:
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject(new XMLElementReference(name.toString()));
											((XMLSequence)RESULT).setMinMaxOccurs(0, 1);
										:} |
									Name:name STAR
										{:
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject(new XMLElementReference(name.toString()));
											((XMLSequence)RESULT).setMinMaxOccurs(0, Constants.INFINITY);
										:} |
									Name:name PLUS
										{:
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject(new XMLElementReference(name.toString()));
											((XMLSequence)RESULT).setMinMaxOccurs(1, Constants.INFINITY);
										:} |
									choice:c
										{:
											DBC.ASSERT(c instanceof XMLAlternative);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLAlternative)c);
											((XMLSequence)RESULT).setMinMaxOccurs(1, 1);
										:} |
									choice:c QMARK
										{:
											DBC.ASSERT(c instanceof XMLAlternative);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLAlternative)c);
											((XMLSequence)RESULT).setMinMaxOccurs(0, 1);
										:} |
									choice:c STAR
										{:
											DBC.ASSERT(c instanceof XMLAlternative);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLAlternative)c);
											((XMLSequence)RESULT).setMinMaxOccurs(0, Constants.INFINITY);
										:} |
									choice:c PLUS
										{:
											DBC.ASSERT(c instanceof XMLAlternative);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLAlternative)c);
											((XMLSequence)RESULT).setMinMaxOccurs(1, Constants.INFINITY);
										:} |
									seq:s
										{:
											DBC.ASSERT(s instanceof XMLSequence);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLSequence)s);
											((XMLSequence)RESULT).setMinMaxOccurs(1, 1);
										:} |
									seq:s QMARK
										{:
											DBC.ASSERT(s instanceof XMLSequence);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLSequence)s);
											((XMLSequence)RESULT).setMinMaxOccurs(0, 1);
										:} |
									seq:s STAR
										{:
											DBC.ASSERT(s instanceof XMLSequence);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLSequence)s);
											((XMLSequence)RESULT).setMinMaxOccurs(0, Constants.INFINITY);
										:} |
									seq:s PLUS
										{:
											DBC.ASSERT(s instanceof XMLSequence);
											RESULT = new XMLSequence();
											((XMLSequence)RESULT).addObject((XMLSequence)s);
											((XMLSequence)RESULT).setMinMaxOccurs(1, Constants.INFINITY);
										:};
// Page 13
DeclSep							::= s;
// Page 28
DefaultDecl						::= HASH_REQUIRED
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setDefaultDecl(XMLAttribute.DefaultType.REQUIRED, null);
										:} |
									HASH_IMPLIED
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setDefaultDecl(XMLAttribute.DefaultType.IMPLIED, null);
										:} |
									HASH_FIXED s AttValue:value
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setDefaultDecl(XMLAttribute.DefaultType.FIXED, value.toString());
										:} |
									AttValue:value
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setDefaultDecl(XMLAttribute.DefaultType.ATTVALUE, value.toString());
										:};
// Page 21
elementdecl						::= ELEMENT_HEAD s Name:name s contentspec:contents GT_PRECEDED_BY_OPT_S
										{:
											RESULT = contents;
											((XMLElement)RESULT).setName(name.toString());
										:};
// Page 35
EntityDecl						::= GEDecl:gedecl
										{:
											RESULT = gedecl;
										:};
// Page 35
EntityDef						::= EntityValue:value
										{:
											RESULT = new XMLEntity(value.toString());
										:} |
									ExternalID:e
										{:
											DBC.ASSERT(e instanceof XMLExternalIdentifier);
											RESULT = new XMLEntity((XMLExternalIdentifier)e);
										:} |
									ExternalID:e NDataDecl:n
										{:
											DBC.ASSERT(e instanceof XMLExternalIdentifier);
											RESULT = new XMLEntity((XMLExternalIdentifier)e, n.toString());
										:};
// Page 33
EntityRef						::= AMP Name:name SEMI
										{:
											// XXX TODO: BUG XXX
											RESULT = "entityLookup(" + name + ")";
										:};
// Page 9
EntityValue						::= QUOT EntityValue_QUOT_STRING:value QUOT
										{:
											RESULT = value;
										:} |
									APOS EntityValue_APOS_STRING:value APOS
										{:
											RESULT = value;
										:};
// A string made up of the characters allowed between quote marks in an EntityValue production
EntityValue_QUOT_STRING			::= /* ε */
										{:
											RESULT = "";
										:} |
									EntityValue_QUOT_STRING:a EntityValue_QUOT_STRING_CHAR:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									EntityValue_QUOT_STRING:a Reference:b
										{:
											RESULT = a.toString() + b.toString();
										:};
// The characters allowed between quote marks in an EntityValue production
EntityValue_QUOT_STRING_CHAR	::= CHAR:value
										{:
											RESULT = value;
										:} |
									APOS
										{:
											RESULT = "'";
										:} |
									AT
										{:
											RESULT = "@";
										:} |
									BACKTICK
										{:
											RESULT = "`";
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH
										{:
											RESULT = "\\";
										:} |
									CARAT
										{:
											RESULT = "^";
										:} |
									COLON
										{:
											RESULT = ":";
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA
										{:
											RESULT = ",";
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR
										{:
											RESULT = "$";
										:} |
									DOT
										{:
											RESULT = ".";
										:} |
									EQUALS
										{:
											RESULT = "=";
										:} |
									EXCLAM
										{:
											RESULT = "!";
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT
										{:
											RESULT = ">";
										:} |
									HASH
										{:
											RESULT = "#";
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE
										{:
											RESULT = "{";
										:} |
									LPAREN
										{:
											RESULT = "(";
										:} |
									LSQUARE
										{:
											RESULT = "[";
										:} |
									LT
										{:
											RESULT = "<";
										:} |
									MINUS
										{:
											RESULT = "-";
										:} |
									PLUS
										{:
											RESULT = "+";
										:} |
									QMARK
										{:
											RESULT = "?";
										:} |
									RBRACE
										{:
											RESULT = "}";
										:} |
									RPAREN
										{:
											RESULT = ")";
										:} |
									RSQUARE
										{:
											RESULT = "]";
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI
										{:
											RESULT = ";";
										:} |
									SLASH
										{:
											RESULT = "/";
										:} |
									STAR
										{:
											RESULT = "*";
										:} |
									TILDE
										{:
											RESULT = "~";
										:} |
									UNDERSCORE
										{:
											RESULT = "_";
										:} |
									HASH_PCDATA
										{:
											RESULT = "#PCDATA";
										:} |
									HASH_FIXED
										{:
											RESULT = "#FIXED";
										:} |
									HASH_IMPLIED
										{:
											RESULT = "#IMPLIED";
										:} |
									HASH_REQUIRED
										{:
											RESULT = "#REQUIRED";
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NDATA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:} |
									COMMA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:};
// A string made up of the characters allowed between apostrophes in an EntityValue production
EntityValue_APOS_STRING			::= /* ε */
										{:
											RESULT = "";
										:} |
									EntityValue_APOS_STRING:a EntityValue_APOS_STRING_CHAR:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									EntityValue_APOS_STRING:a Reference:b
										{:
											RESULT = a.toString() + b.toString();
										:};
// The characters allowed between apostrophes in an EntityValue production
EntityValue_APOS_STRING_CHAR	::= CHAR:value
										{:
											RESULT = value;
										:} |
									AT
										{:
											RESULT = "@";
										:} |
									BACKTICK
										{:
											RESULT = "`";
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH
										{:
											RESULT = "\\";
										:} |
									CARAT
										{:
											RESULT = "^";
										:} |
									COLON
										{:
											RESULT = ":";
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA
										{:
											RESULT = ",";
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR
										{:
											RESULT = "$";
										:} |
									DOT
										{:
											RESULT = ".";
										:} |
									EQUALS
										{:
											RESULT = "=";
										:} |
									EXCLAM
										{:
											RESULT = "!";
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT
										{:
											RESULT = ">";
										:} |
									HASH
										{:
											RESULT = "#";
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE
										{:
											RESULT = "{";
										:} |
									LPAREN
										{:
											RESULT = "(";
										:} |
									LSQUARE
										{:
											RESULT = "[";
										:} |
									LT
										{:
											RESULT = "<";
										:} |
									MINUS
										{:
											RESULT = "-";
										:} |
									PLUS
										{:
											RESULT = "+";
										:} |
									QMARK
										{:
											RESULT = "?";
										:} |
									QUOT
										{:
											RESULT = "\"";
										:} |
									RBRACE
										{:
											RESULT = "}";
										:} |
									RPAREN
										{:
											RESULT = ")";
										:} |
									RSQUARE
										{:
											RESULT = "]";
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI
										{:
											RESULT = ";";
										:} |
									SLASH
										{:
											RESULT = "/";
										:} |
									STAR
										{:
											RESULT = "*";
										:} |
									TILDE
										{:
											RESULT = "~";
										:} |
									UNDERSCORE
										{:
											RESULT = "_";
										:} |
									HASH_PCDATA
										{:
											RESULT = "#PCDATA";
										:} |
									HASH_FIXED
										{:
											RESULT = "#FIXED";
										:} |
									HASH_IMPLIED
										{:
											RESULT = "#IMPLIED";
										:} |
									HASH_REQUIRED
										{:
											RESULT = "#REQUIRED";
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NDATA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:} |
									COMMA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:};
// Page 27
EnumeratedType					::= NotationType:nType
										{:
											RESULT = nType;
										:} |
									Enumeration:eType
										{:
											RESULT = eType;
										:};
// Page 27
Enumeration						::= LPAREN_FOLLOWED_BY_OPT_S Nmtoken:nmtoken RPAREN_PRECEDED_BY_OPT_S
										{:
											// The vector of all the values
											List<String> values = new ArrayList<String>();

											// This Enumeration has only one possible value
											values.add(nmtoken);

											// Make the new XMLAttribute, set its type and give it the values
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.ENUMERATION, values);
										:} |
									LPAREN_FOLLOWED_BY_OPT_S Nmtoken:nmtoken Enumeration_NmtokenLIST:nmtokens RPAREN_PRECEDED_BY_OPT_S
										{:
											// The vector of all the values
											List<String> values = new ArrayList<String>();

											// Add the first name to the vector
											values.add(nmtoken);

											// Add the rest of the names to the vector
											DBC.ASSERT(nmtokens instanceof List);
											for (Object token : nmtokens) {
												values.add(token.toString());
											}

											// Make the new XMLAttribute, set its type and give it the values
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.ENUMERATION, values);
										:};
// (S? '|' S? Nmtoken)+
Enumeration_NmtokenLIST			::= PIPE_SURROUNDED_WITH_OPT_S Nmtoken:nmtoken
										{:
											List<String> value = new ArrayList<String>();
											value.add(nmtoken);
											RESULT = value;
										:} |
									Enumeration_NmtokenLIST:values PIPE_SURROUNDED_WITH_OPT_S Nmtoken:nmtoken
										{:
											List<String> newTokenList = new ArrayList<String>();

											DBC.ASSERT(values instanceof List);
											for (Object token : values) {
												newTokenList.add(token.toString());
											}

											DBC.ASSERT(nmtoken instanceof String);
											newTokenList.add(nmtoken);

											RESULT = newTokenList;
										:};
// Page 36
ExternalID						::= SYSTEM s SystemLiteral:uri
										{:
											RESULT = new XMLExternalIdentifier(null, uri.toString());
										:} |
									PublicID:pubid s SystemLiteral:uri
										{:
											RESULT = new XMLExternalIdentifier(pubid.toString(), uri.toString());
										:};
// Page 14
extSubset						::= extSubsetDecl:eSD
										{:
											List<XMLMarkupDeclaration> newExtSubSet = new ArrayList<XMLMarkupDeclaration>();

											DBC.ASSERT(eSD instanceof List);
											for (Object markupDecl : eSD) {
												newExtSubSet.add((XMLMarkupDeclaration)markupDecl);
											}
											
											RESULT = new XMLDocumentType(newExtSubSet);
										:};
// Page 14
extSubsetDecl					::= /* ε */
										{:
											RESULT = new ArrayList<XMLMarkupDeclaration>();
										:} |
									markupDecl:a extSubsetDecl:b
										{:
											DBC.ASSERT(a == null || a instanceof XMLMarkupDeclaration);
											DBC.ASSERT(b instanceof List);

											List<XMLMarkupDeclaration> newDecls = new ArrayList<XMLMarkupDeclaration>();
											
											newDecls.add((XMLMarkupDeclaration)a);
											for (Object listMarkup : b) {
												newDecls.add((XMLMarkupDeclaration)listMarkup);
											}
											RESULT = newDecls;
										:} |
									DeclSep extSubsetDecl:eSD
										{:
											RESULT = eSD;
										:};
// Page 35
GEDecl							::= ENTITY_HEAD s Name:name s EntityDef:value GT_PRECEDED_BY_OPT_S
										{:
											DBC.ASSERT(value instanceof XMLEntity);
											((XMLEntity)value).setName(name.toString());
											RESULT = value;
										:};
// S? '>'
GT_PRECEDED_BY_OPT_S			::= GT
										{:
											RESULT = ">";
										:} |
									s:s GT
										{:
											RESULT = s.toString() + ">";
										:};
// '(' S?
LPAREN_FOLLOWED_BY_OPT_S		::= LPAREN
										{:
											RESULT = "(";
										:} |
									LPAREN s:s
										{:
											RESULT = "(" + s.toString();
										:};
// Page 13
markupDecl						::= elementdecl:e
										{:
											RESULT = e;
										:} |
									AttlistDecl:a
										{:
											RESULT = a;
										:} |
									EntityDecl:e
										{:
											RESULT = e;
										:} |
									NotationDecl:n
										{:
											RESULT = n;
										:} |
									COMMENT
										{:
											/* Ignore this, it's a comment token */
											RESULT = null;
										:};
// Page 23
Mixed							::= LPAREN_FOLLOWED_BY_OPT_S HASH_PCDATA Mixed_NameLIST:mixed RPAREN_PRECEDED_BY_OPT_S STAR
										{:
											RESULT = new XMLMixedContent();
											((XMLMixedContent)RESULT).addObject(new XMLContent());
											DBC.ASSERT(mixed instanceof XMLMixedContent);
											((XMLMixedContent)RESULT).append((XMLMixedContent)mixed);
										:} |
									LPAREN_FOLLOWED_BY_OPT_S HASH_PCDATA RPAREN_PRECEDED_BY_OPT_S STAR
										{:
											RESULT = new XMLMixedContent();
											((XMLMixedContent)RESULT).addObject(new XMLContent());
										:} |
									LPAREN_FOLLOWED_BY_OPT_S HASH_PCDATA RPAREN_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLMixedContent();
											((XMLMixedContent)RESULT).addObject(new XMLContent());
										:};
// (S? '|' S? Name)+
Mixed_NameLIST					::= PIPE_SURROUNDED_WITH_OPT_S Name:name
										{:
											RESULT = new XMLMixedContent();
											((XMLMixedContent)RESULT).addObject(new XMLElementReference(name.toString()));
										:} |
									Mixed_NameLIST:mixed PIPE_SURROUNDED_WITH_OPT_S Name:name
										{:
											DBC.ASSERT(mixed instanceof XMLMixedContent);
											RESULT = mixed;
											((XMLMixedContent)RESULT).addObject(new XMLElementReference(name.toString()));
										:};
// Page 8
Name							::= NameStartChar:a NameChar_STAR:b
										{:
											RESULT = a.toString() + b.toString();
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREF:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:};
// Page 8
NameChar						::= NameStartChar:value
										{:
											RESULT = value;
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOT:value
										{:
											RESULT = value;
										:} |
									MINUS:value
										{:
											RESULT = value;
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREF:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:};
// NameChar*
NameChar_STAR					::= /* ε */
										{:
											RESULT = "";
										:} |
									NameChar_STAR:a NameChar:b
										{:
											RESULT = a.toString() + b.toString();
										:};
// Characters that may start a Name token
NameStartChar					::= BASECHAR:value
										{:
											RESULT = value;
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									UNDERSCORE
										{:
											RESULT = "_";
										:} |
									COLON
										{:
											RESULT = ":";
										:};
// Page 36
NDataDecl						::=	NDATA_SURROUNDED_BY_S Name:name
										{:
											RESULT = name;
										:};
// Page 8
Nmtoken							::= NameChar_STAR:a NameChar:b
										{:
											RESULT = a.toString() + b.toString();
										:};
// Page 44
NotationDecl					::= NOTATION_HEAD s Name:name s ExternalID:extID GT_PRECEDED_BY_OPT_S
										{:
											DBC.ASSERT(extID instanceof XMLExternalIdentifier);
											RESULT = new XMLNotation(name.toString(), (XMLExternalIdentifier)extID);
										:} |
									NOTATION_HEAD s Name:name s PublicID:pubID GT_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLNotation(name.toString(), new XMLExternalIdentifier(pubID.toString(), null));
										:};
// Page 27
NotationType					::= NOTATION s LPAREN_FOLLOWED_BY_OPT_S Name:name RPAREN_PRECEDED_BY_OPT_S
										{:
											// The vector of all the values
											List<String> values = new ArrayList<String>();

											// This NotationType has only one possible value
											String notationName = name.toString();
											values.add(notationName);

											// Make the new XMLAttribute, set its type and give it the values
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.NOTATION, values);
										:} |
									NOTATION s LPAREN_FOLLOWED_BY_OPT_S Name:name NotationType_NameLIST:names RPAREN_PRECEDED_BY_OPT_S
										{:
											// The vector of all the values
											List<String> values = new ArrayList<String>();

											// Add the first name to the vector
											String notationName = name.toString();
											values.add(notationName);

											// Add the rest of the names to the vector
											DBC.ASSERT(names instanceof List);
											for (Object listName : names) {
												values.add(listName.toString());
											}

											// Make the new XMLAttribute, set its type and give it the values
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.NOTATION, values);
										:};
// (S? '|' S? Name)+
NotationType_NameLIST			::= PIPE_SURROUNDED_WITH_OPT_S Name:name
										{:
											List<String> value = new ArrayList<String>();
											value.add(name);
											RESULT = value;
										:} |
									NotationType_NameLIST:values PIPE_SURROUNDED_WITH_OPT_S Name:name
										{:
											List<String> newValues = new ArrayList<String>();
											
											// Copy in the values
											DBC.ASSERT(values instanceof List);
											for (Object newValue : values) {
												newValues.add(newValue.toString());
											}
											
											// Add the name on the end.
											newValues.add(name.toString());

											RESULT = newValues;
										:};
// S? '|' S?
PIPE_SURROUNDED_WITH_OPT_S		::= PIPE
										{:
											RESULT = "|";
										:} |
									PIPE_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:};
// Page 9
PubidLiteral					::= QUOT Char_NO_QUOT_STAR:value QUOT
										{:
											RESULT = value;
										:} |
									APOS Char_NO_APOS_STAR:value APOS
										{:
											RESULT = value;
										:};
// Page 44
PublicID						::= PUBLIC s PubidLiteral:value
										{:
											RESULT = value;
										:};
// Page 33
Reference						::= EntityRef:entityRefObject
										{:
											RESULT = entityRefObject;
										:} |
									CHARREF:value
										{:
											RESULT = value;
										:};
// S? ')'
RPAREN_PRECEDED_BY_OPT_S		::= RPAREN
										{:
											RESULT = ")";
										:} |
									s:s RPAREN
										{:
											RESULT = s.toString() + ")";
										:};
// S+
s								::= S:value
										{:
											RESULT = value;
										:} |
									s:a S:b
										{:
											RESULT = a.toString() + b.toString();
										:};
// Page 22
seq								::= LPAREN_FOLLOWED_BY_OPT_S cp:cp RPAREN_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLSequence();
											DBC.ASSERT(cp instanceof XMLObject);
											((XMLSequence)RESULT).addObject((XMLObject)cp);
										:} |
									LPAREN_FOLLOWED_BY_OPT_S cp:cp seq_cpLIST:seq RPAREN_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLSequence();
											DBC.ASSERT(cp instanceof XMLObject);
											DBC.ASSERT(seq instanceof XMLSequence);
											((XMLSequence)RESULT).addObject((XMLObject)cp);
											((XMLSequence)RESULT).append((XMLSequence)seq);
										:};
// (S? ',' S?)+
seq_cpLIST						::= COMMA_SURROUNDED_BY_OPT_S cp:cp
										{:
											RESULT = new XMLSequence();
											DBC.ASSERT(cp instanceof XMLObject);
											((XMLSequence)RESULT).addObject((XMLObject)cp);
										:} |
									seq_cpLIST:seq COMMA_SURROUNDED_BY_OPT_S cp:cp
										{:
											RESULT = seq;
											DBC.ASSERT(cp instanceof XMLObject);
											((XMLSequence)RESULT).addObject((XMLObject)cp);
										:};
// Page 25
StringType						::= CDATA
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.CDATA);
										:};
// Page 9
SystemLiteral					::= QUOT Char_NO_QUOT_STAR:value QUOT
										{:
											RESULT = value;
										:} |
									APOS Char_NO_APOS_STAR:value APOS
										{:
											RESULT = value;
										:};
// Page 25
TokenizedType					::= ID
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.ID);
										:} |
									IDREF
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.IDREF);
										:} |
									IDREFS
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.IDREFS);
										:} |
									ENTITY
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.ENTITY);
										:} |
									ENTITIES
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.ENTITIES);
										:} |
									NMTOKEN
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.NMTOKEN);
										:} |
									NMTOKENS
										{:
											RESULT = new XMLAttribute();
											((XMLAttribute)RESULT).setType(XMLAttribute.ContentType.NMTOKENS);
										:};
