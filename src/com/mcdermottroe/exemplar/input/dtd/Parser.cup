// vim:filetype=javacup:ts=4
/*
	Copyright (c) 2003-2007
	Conor McDermottroe.  All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:
	1. Redistributions of source code must retain the above copyright
	   notice, this list of conditions and the following disclaimer.
	2. Redistributions in binary form must reproduce the above copyright
	   notice, this list of conditions and the following disclaimer in the
	   documentation and/or other materials provided with the distribution.
	3. Neither the name of the author nor the names of any contributors to
	   the software may be used to endorse or promote products derived from
	   this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
	TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
	OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.Symbol;

import com.mcdermottroe.exemplar.Constants;
import com.mcdermottroe.exemplar.Copyable;
import com.mcdermottroe.exemplar.DBC;
import com.mcdermottroe.exemplar.Utils;
import com.mcdermottroe.exemplar.input.InputModule;
import com.mcdermottroe.exemplar.input.ParserException;
import com.mcdermottroe.exemplar.model.XMLAlternative;
import com.mcdermottroe.exemplar.model.XMLAttribute;
import com.mcdermottroe.exemplar.model.XMLAttributeContentType;
import com.mcdermottroe.exemplar.model.XMLAttributeDefaultType;
import com.mcdermottroe.exemplar.model.XMLAttributeList;
import com.mcdermottroe.exemplar.model.XMLContent;
import com.mcdermottroe.exemplar.model.XMLDocumentType;
import com.mcdermottroe.exemplar.model.XMLElement;
import com.mcdermottroe.exemplar.model.XMLElementContentModel;
import com.mcdermottroe.exemplar.model.XMLElementContentType;
import com.mcdermottroe.exemplar.model.XMLElementReference;
import com.mcdermottroe.exemplar.model.XMLEntity;
import com.mcdermottroe.exemplar.model.XMLExternalIdentifier;
import com.mcdermottroe.exemplar.model.XMLMixedContent;
import com.mcdermottroe.exemplar.model.XMLNamedObject;
import com.mcdermottroe.exemplar.model.XMLNotation;
import com.mcdermottroe.exemplar.model.XMLSequence;
import com.mcdermottroe.exemplar.ui.Log;
import com.mcdermottroe.exemplar.ui.Message;
import com.mcdermottroe.exemplar.ui.Options;

parser code {:
	/** A {@link Map} from symbol numbers to symbol names for debug messages. */
	private Map<Integer, String> symbolNames;

	/** Implementation of {@link InputModule#parse(String)}.

		@param dtdFile			The path to the file to parse from.
		@return					An {@link XMLDocumentType} representing the
								vocabulary described by the DTD at
								<code>dtdFile</code>.
		@throws	ParserException if {@link #parse(File)} throws one.
	*/
	public XMLDocumentType parse(String dtdFile)
	throws ParserException
	{
		DBC.REQUIRE(dtdFile != null);
		if ("-".equals(dtdFile)) {
			return parse(System.in, new File(Constants.CWD));
		}
		return parse(new File(dtdFile));
	}

	/** Implementation of {@link InputModule#parse(File)}.

		@param dtdFile			The file to parse from.
		@return					An {@link XMLDocumentType} representing the
								vocabulary described by the DTD at
								<code>dtdFile</code>.
		@throws	ParserException if {@link #parse(File)} throws one.
	*/
	public XMLDocumentType parse(File dtdFile)
	throws ParserException
	{
		DBC.REQUIRE(dtdFile != null);
		try {
			File dir = dtdFile.getParentFile();
			if (dir != null) {
				return parse(new FileInputStream(dtdFile), dir);
			} else {
				return parse(new FileInputStream(dtdFile));
			}
		} catch (FileNotFoundException e) {
			throw new ParserException(
				Message.DTDLEXER_INPUT_NOT_FOUND(dtdFile.getAbsolutePath()),
				e
			);
		}
	}

	/** Implementation of {@link InputModule#parse(InputStream)}.

		@param dtdSource		The input source to parse from.
		@return					An {@link XMLDocumentType} representing the
								vocabulary described by the DTD at
								<code>dtdFile</code>.
		@throws	ParserException if {@link #parse(File)} throws one.
	*/
	public XMLDocumentType parse(InputStream dtdSource)
	throws ParserException
	{
		DBC.REQUIRE(dtdSource != null);
		return parse(dtdSource, new File(Constants.CWD));
	}


	/** Workhorse for {@link #parse(String)}, {@link #parse(File)} and {@link
		#parse(InputStream)}.

		@param input			The input source providing the DTD text.
		@param baseDir			A directory to use when converting relative
								paths in the DTD into absolute paths.
		@return					An {@link XMLDocumentType} representing the
								vocabulary described by the DTD at
								<code>dtdFile</code>.
		@throws ParserException	if the lexer can't find the input file
	*/
	private XMLDocumentType parse(InputStream input, File baseDir)
	throws ParserException
	{
		DBC.REQUIRE(input != null);
		DBC.REQUIRE(baseDir != null);

		// Set the symbol factory
		symbolFactory = new ComplexSymbolFactory();

		// Create the lexer and set it as the scanner.
		Lexer lex;
		try {
			lex = new Lexer(new InputStreamReader(input, "UTF8"));
		} catch (UnsupportedEncodingException e) {
			lex = new Lexer(input);
		}
		lex.setDtdPath(baseDir);
		setScanner(lex);

		// Actually go and do the parse.
		try {
			if (Options.isDebugSet() && Options.getInteger("debug-level") > 1) {
				return (XMLDocumentType)((Symbol)debug_parse()).value;
			} else {
				return (XMLDocumentType)((Symbol)parse()).value;
			}
		} catch (Exception e) {
			throw new ParserException(Message.DTDPARSER_THREW_EXCEPTION(), e);
		}
	}

	/** Log a debug message.

		@param	message	The message to log.
	*/
	public void debug_message(String message) {
		if (Options.isDebugSet() && Options.getInteger("debug-level") >= 2) {
			if (symbolNames == null) {
				symbolNames = new HashMap<Integer, String>();
				Field[] fields = ParserSymbols.class.getDeclaredFields();
				for (Field field : fields) {
					try {
						symbolNames.put(field.getInt(null), field.getName());
					} catch (IllegalAccessException e) {
						// Do nothing
					}
				}
			}
			if (message != null && message.matches(".*# Current (Symbol|token) is #.*")) {
				try {
					int symbolNumber = Integer.parseInt(
						message.substring(message.lastIndexOf('#') + 1)
					);
					message += " (" + symbolNames.get(symbolNumber) + ")";
				} catch (NumberFormatException e) {
					message += " (<<<Unknown symbol!>>>)";
				}
			}
			Log.debug(message);
		}
	}

	public int compareTo(Parser other) {
		if (other == null) {
			throw new NullPointerException();
		}
		return 0;
	}

	/** {@inheritDoc}

		Note: The SymbolFactory, parse stack and values associated with the symbols in the lookahead are reference-copied.
	*/
	public Parser getCopy() {
		Parser copy = new Parser();

		// Copy _done_parsing
		copy._done_parsing = _done_parsing;

		// Copy action_obj
		if (action_obj != null) {
			copy.action_obj = new CUP$Parser$actions(copy);
		} else {
			copy.action_obj = null;
		}

		// Copy action_tab
		if (action_tab != null) {
			copy.action_tab = new short[action_tab.length][];
			for (int i = 0; i < action_tab.length; i++) {
				copy.action_tab[i] = new short[action_tab[i].length];
				System.arraycopy(action_tab[i], 0, copy.action_tab[i], 0, action_tab[i].length);
			}
		} else {
			copy.action_tab = null;
		}

		// Copy cur_token
		if (cur_token != null) {
			copy.cur_token = new Symbol(cur_token.sym, cur_token.left, cur_token.right, cur_token.value);
			copy.cur_token.parse_state = cur_token.parse_state;
		} else {
			copy.cur_token = null;
		}

		// Copy lookahead
		if (lookahead != null) {
			copy.lookahead = new Symbol[lookahead.length];
			for (int i = 0; i < lookahead.length; i++) {
				copy.lookahead[i] = new Symbol(lookahead[i].sym, lookahead[i].left, lookahead[i].right, lookahead[i].value);
				copy.lookahead[i].parse_state = lookahead[i].parse_state;
			}
		} else {
			copy.lookahead = null;
		}

		// Copy lookahead_pos
		copy.lookahead_pos = lookahead_pos;

		// Copy production_tab
		if (production_tab != null) {
			copy.production_tab = new short[production_tab.length][];
			for (int i = 0; i < production_tab.length; i++) {
				copy.production_tab[i] = new short[production_tab[i].length];
				System.arraycopy(production_tab[i], 0, copy.production_tab[i], 0, production_tab[i].length);
			}
		} else {
			copy.production_tab = null;
		}

		// Copy reduce_tab
		if (reduce_tab != null) {
			copy.reduce_tab = new short[reduce_tab.length][];
			for (int i = 0; i < reduce_tab.length; i++) {
				copy.reduce_tab[i] = new short[reduce_tab[i].length];
				System.arraycopy(reduce_tab[i], 0, copy.reduce_tab[i], 0, reduce_tab[i].length);
			}
		} else {
			copy.reduce_tab = null;
		}

		// Copy stack
		copy.stack = stack;

		// Copy symbolFactory
		copy.symbolFactory = symbolFactory;

		// Copy tos
		copy.tos = tos;

		return copy;
	}

	/** Implement {@link Object#equals(Object)}.

		@param	o	The other {@link Object} to compare against.
		@return		True if this is equal to o.
	*/
	@Override public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null) {
			return false;
		}
		if (!(o instanceof Parser)) {
			return false;
		}

		Parser other = (Parser)o;
		return	Utils.areAllDeeplyEqual(
					production_table(),
					other.production_table()
				) &&
				Utils.areAllDeeplyEqual(action_table(), other.action_table()) &&
				Utils.areAllDeeplyEqual(reduce_table(), other.reduce_table());
	}

	/** Implement {@link Object#hashCode()}. */
	@Override public int hashCode() {
		return Utils.genericHashCode(
			production_table(),
			action_table(),
			reduce_table()
		);
	}

	/** {@inheritDoc} */
	public String toString() {
		return "The input file is a DTD.";
	}
:}

terminal String	ATTLIST_HEAD;
terminal String	ELEMENT_HEAD;
terminal String	ENTITY_HEAD;
terminal String NOTATION_HEAD;
terminal String	HASH_PCDATA;
terminal String	HASH_FIXED;
terminal String	HASH_IMPLIED;
terminal String	HASH_REQUIRED;
terminal String	CDATA;
terminal String	SYSTEM;
terminal String	PUBLIC;
terminal String	NDATA_SURROUNDED_BY_S;
terminal String	NOTATION;
terminal String	EMPTY;
terminal String	ANY;
terminal String	ID;
terminal String	IDREF;
terminal String	IDREFS;
terminal String	ENTITY;
terminal String	ENTITIES;
terminal String	NMTOKEN;
terminal String	NMTOKENS;
terminal String	S;
terminal String	AMP;
terminal String	APOS;
terminal String	AT;
terminal String	BACKTICK;
terminal String	BASECHAR;
terminal String	BSLASH;
terminal String	CARAT;
terminal String	CHAR;
terminal String	CHARREF;
terminal String	COLON;
terminal String	COMBININGCHAR;
terminal String	COMMA;
terminal String	COMMA_PRECEDED_BY_S;
terminal String	COMMA_FOLLOWED_BY_S;
terminal String	COMMA_SURROUNDED_BY_S;
terminal String	COMMENT;
terminal String	DIGIT;
terminal String	DOLLAR;
terminal String	DOT;
terminal String	EQUALS;
terminal String	EXCLAM;
terminal String	EXTENDER;
terminal String	GT;
terminal String	HASH;
terminal String	IDEOGRAPHIC;
terminal String	LBRACE;
terminal String	LPAREN;
terminal String	LSQUARE;
terminal String	LT;
terminal String	MINUS;
terminal String	PERCENT;
terminal String	PIPE;
terminal String	PIPE_PRECEDED_BY_S;
terminal String	PIPE_FOLLOWED_BY_S;
terminal String	PIPE_SURROUNDED_BY_S;
terminal String	PLUS;
terminal String	QMARK;
terminal String	QUOT;
terminal String	RBRACE;
terminal String	RPAREN;
terminal String	RSQUARE;
terminal String	SEMI;
terminal String	SLASH;
terminal String	STAR;
terminal String	TILDE;
terminal String	UNDERSCORE;

non terminal XMLAttribute				AttDef;
non terminal List						AttDef_STAR;
non terminal XMLAttributeList			AttlistDecl;
non terminal XMLAttributeContentType	AttType;
non terminal String						AttValue;
non terminal String						AttValue_QUOT_STRING;
non terminal String						AttValue_QUOT_STRING_CHAR;
non terminal String						AttValue_APOS_STRING;
non terminal String						AttValue_APOS_STRING_CHAR;
non terminal String						Char_NO_QUOT;
non terminal String						Char_NO_QUOT_STAR;
non terminal String						Char_NO_APOS;
non terminal String						Char_NO_APOS_STAR;
non terminal XMLSequence				children;
non terminal XMLAlternative				choice;
non terminal XMLAlternative				choice_cpLIST;
non terminal String						COMMA_SURROUNDED_BY_OPT_S;
non terminal XMLElementContentModel		contentspec;
non terminal XMLSequence				cp;
non terminal String						DeclSep;
non terminal XMLAttributeDefaultType	DefaultDecl;
non terminal XMLElement					elementdecl;
non terminal XMLEntity					EntityDecl;
non terminal String						EntityRef;
non terminal String						EntityValue;
non terminal String						EntityValue_QUOT_STRING;
non terminal String						EntityValue_QUOT_STRING_CHAR;
non terminal String						EntityValue_APOS_STRING;
non terminal String						EntityValue_APOS_STRING_CHAR;
non terminal XMLAttributeContentType	Enumeration;
non terminal List						Enumeration_NmtokenLIST;
non terminal XMLAttributeContentType	EnumeratedType;
non terminal XMLExternalIdentifier		ExternalID;
non terminal XMLDocumentType			extSubset;
non terminal List						extSubsetDecl;
non terminal XMLEntity					GEDecl;
non terminal String						GT_PRECEDED_BY_OPT_S;
non terminal String						LPAREN_FOLLOWED_BY_OPT_S;
non terminal XMLNamedObject				markupDecl;
non terminal XMLMixedContent			Mixed;
non terminal XMLMixedContent			Mixed_NameLIST;
non terminal String						Name;
non terminal String						NameChar;
non terminal String						NameChar_STAR;
non terminal String						NameStartChar;
non terminal String						NDataDecl;
non terminal String						Nmtoken;
non terminal XMLNotation				NotationDecl;
non terminal XMLAttributeContentType	NotationType;
non terminal List						NotationType_NameLIST;
non terminal String						PIPE_SURROUNDED_WITH_OPT_S;
non terminal String						PubidLiteral;
non terminal String						PublicID;
non terminal String						Reference;
non terminal String						RPAREN_PRECEDED_BY_OPT_S;
non terminal String						s;
non terminal XMLSequence				seq;
non terminal XMLSequence				seq_cpLIST;
non terminal XMLAttributeContentType	StringType;
non terminal String						SystemLiteral;
non terminal XMLAttributeContentType	TokenizedType;

precedence nonassoc BASECHAR, COLON, COMBININGCHAR, DIGIT, DOT, EXTENDER, IDEOGRAPHIC, MINUS, S, UNDERSCORE;

start with extSubset;

// Page 24
AttDef							::= s Name:name s AttType:type s DefaultDecl:defaultDecl
										{:
											RESULT = new XMLAttribute(name, type, defaultDecl);
											Log.debug("Parsed an attribute: " + RESULT);
										:};
// AttDef*
AttDef_STAR						::= /* ε */
										{:
											RESULT = new ArrayList();
										:} |
									AttDef_STAR:list AttDef:attdef
										{:
											list.add(attdef);
											RESULT = list;
										:};
// Page 24
AttlistDecl						::=	ATTLIST_HEAD s Name:name AttDef_STAR:atts GT_PRECEDED_BY_OPT_S
										{:
											List<XMLAttribute> attributes = new ArrayList<XMLAttribute>(atts.size());
											for (Object o : atts) {
												attributes.add(XMLAttribute.class.cast(o));
											}
											RESULT = new XMLAttributeList(name, attributes);
										:};
// Page 25
AttType							::=	StringType:type
										{:
											RESULT = type;
										:} |
									TokenizedType:type
										{:
											RESULT = type;
										:} |
									EnumeratedType:type
										{:
											RESULT = type;
										:};
// Page 9
AttValue						::= QUOT AttValue_QUOT_STRING:value QUOT
										{:
											RESULT = value;
										:} |
									APOS AttValue_APOS_STRING:value APOS
										{:
											RESULT = value;
										:};
// A string of the characters allowed between quote marks in an AttValue production
AttValue_QUOT_STRING			::= /* ε */
										{:
											RESULT = "";
										:} |
									AttValue_QUOT_STRING:a AttValue_QUOT_STRING_CHAR:b
										{:
											RESULT = a + b;
										:} |
									AttValue_QUOT_STRING:a Reference:b
										{:
											RESULT = a + b;
										:};
// The characters allowed between quote marks in an AttValue production
AttValue_QUOT_STRING_CHAR		::= CHAR:value
										{:
											RESULT = value;
										:} |
									APOS:value
										{:
											RESULT = value;
										:} |
									AT:value
										{:
											RESULT = value;
										:} |
									BACKTICK:value
										{:
											RESULT = value;
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH:value
										{:
											RESULT = value;
										:} |
									CARAT:value
										{:
											RESULT = value;
										:} |
									COLON:value
										{:
											RESULT = value;
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA:value
										{:
											RESULT = value;
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR:value
										{:
											RESULT = value;
										:} |
									DOT:value
										{:
											RESULT = value;
										:} |
									EQUALS:value
										{:
											RESULT = value;
										:} |
									EXCLAM:value
										{:
											RESULT = value;
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT:value
										{:
											RESULT = value;
										:} |
									HASH:value
										{:
											RESULT = value;
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE:value
										{:
											RESULT = value;
										:} |
									LPAREN:value
										{:
											RESULT = value;
										:} |
									LSQUARE:value
										{:
											RESULT = value;
										:} |
									MINUS:value
										{:
											RESULT = value;
										:} |
									PERCENT:value
										{:
											RESULT = value;
										:} |
									PLUS:value
										{:
											RESULT = value;
										:} |
									QMARK:value
										{:
											RESULT = value;
										:} |
									RBRACE:value
										{:
											RESULT = value;
										:} |
									RPAREN:value
										{:
											RESULT = value;
										:} |
									RSQUARE:value
										{:
											RESULT = value;
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI:value
										{:
											RESULT = value;
										:} |
									SLASH:value
										{:
											RESULT = value;
										:} |
									STAR:value
										{:
											RESULT = value;
										:} |
									TILDE:value
										{:
											RESULT = value;
										:} |
									UNDERSCORE:value
										{:
											RESULT = value;
										:} |
									HASH_PCDATA:value
										{:
											RESULT = value;
										:} |
									HASH_FIXED:value
										{:
											RESULT = value;
										:} |
									HASH_IMPLIED:value
										{:
											RESULT = value;
										:} |
									HASH_REQUIRED:value
										{:
											RESULT = value;
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NDATA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:} |
									COMMA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:};
// A string of the characters allowed between apostrophes in an AttValue production
AttValue_APOS_STRING			::= /* ε */
										{:
											RESULT = "";
										:} |
									AttValue_APOS_STRING:a AttValue_APOS_STRING_CHAR:b
										{:
											RESULT = a + b;
										:} |
									AttValue_APOS_STRING:a Reference:b
										{:
											RESULT = a + b;
										:};
// The characters allowed between apostrophes in an AttValue production
AttValue_APOS_STRING_CHAR		::= CHAR:value
										{:
											RESULT = value;
										:} |
									AT:value
										{:
											RESULT = value;
										:} |
									BACKTICK:value
										{:
											RESULT = value;
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH:value
										{:
											RESULT = value;
										:} |
									CARAT:value
										{:
											RESULT = value;
										:} |
									COLON:value
										{:
											RESULT = value;
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA:value
										{:
											RESULT = value;
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR:value
										{:
											RESULT = value;
										:} |
									DOT:value
										{:
											RESULT = value;
										:} |
									EQUALS:value
										{:
											RESULT = value;
										:} |
									EXCLAM:value
										{:
											RESULT = value;
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT:value
										{:
											RESULT = value;
										:} |
									HASH:value
										{:
											RESULT = value;
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE:value
										{:
											RESULT = value;
										:} |
									LPAREN:value
										{:
											RESULT = value;
										:} |
									LSQUARE:value
										{:
											RESULT = value;
										:} |
									MINUS:value
										{:
											RESULT = value;
										:} |
									PERCENT:value
										{:
											RESULT = value;
										:} |
									PLUS:value
										{:
											RESULT = value;
										:} |
									QMARK:value
										{:
											RESULT = value;
										:} |
									QUOT:value
										{:
											RESULT = value;
										:} |
									RBRACE:value
										{:
											RESULT = value;
										:} |
									RPAREN:value
										{:
											RESULT = value;
										:} |
									RSQUARE:value
										{:
											RESULT = value;
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI:value
										{:
											RESULT = value;
										:} |
									SLASH:value
										{:
											RESULT = value;
										:} |
									STAR:value
										{:
											RESULT = value;
										:} |
									TILDE:value
										{:
											RESULT = value;
										:} |
									UNDERSCORE:value
										{:
											RESULT = value;
										:} |
									HASH_PCDATA:value
										{:
											RESULT = value;
										:} |
									HASH_FIXED:value
										{:
											RESULT = value;
										:} |
									HASH_IMPLIED:value
										{:
											RESULT = value;
										:} |
									HASH_REQUIRED:value
										{:
											RESULT = value;
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NDATA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:} |
									COMMA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:};
// Char - '"'
Char_NO_QUOT					::= CHAR:value
										{:
											RESULT = value;
										:} |
									AMP:value
										{:
											RESULT = value;
										:} |
									APOS:value
										{:
											RESULT = value;
										:} |
									AT:value
										{:
											RESULT = value;
										:} |
									BACKTICK:value
										{:
											RESULT = value;
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH:value
										{:
											RESULT = value;
										:} |
									CARAT:value
										{:
											RESULT = value;
										:} |
									COLON:value
										{:
											RESULT = value;
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA:value
										{:
											RESULT = value;
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR:value
										{:
											RESULT = value;
										:} |
									DOT:value
										{:
											RESULT = value;
										:} |
									EQUALS:value
										{:
											RESULT = value;
										:} |
									EXCLAM:value
										{:
											RESULT = value;
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT:value
										{:
											RESULT = value;
										:} |
									HASH:value
										{:
											RESULT = value;
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE:value
										{:
											RESULT = value;
										:} |
									LPAREN:value
										{:
											RESULT = value;
										:} |
									LSQUARE:value
										{:
											RESULT = value;
										:} |
									LT:value
										{:
											RESULT = value;
										:} |
									MINUS:value
										{:
											RESULT = value;
										:} |
									PERCENT:value
										{:
											RESULT = value;
										:} |
									PLUS:value
										{:
											RESULT = value;
										:} |
									QMARK:value
										{:
											RESULT = value;
										:} |
									RBRACE:value
										{:
											RESULT = value;
										:} |
									RPAREN:value
										{:
											RESULT = value;
										:} |
									RSQUARE:value
										{:
											RESULT = value;
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI:value
										{:
											RESULT = value;
										:} |
									SLASH:value
										{:
											RESULT = value;
										:} |
									STAR:value
										{:
											RESULT = value;
										:} |
									TILDE:value
										{:
											RESULT = value;
										:} |
									UNDERSCORE:value
										{:
											RESULT = value;
										:};
// Char_NO_QUOT*
Char_NO_QUOT_STAR				::=	/* ε */
										{:
											RESULT = "";
										:} |
									Char_NO_QUOT_STAR:a Char_NO_QUOT:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_QUOT_STAR:a HASH_PCDATA:hp
										{:
											RESULT = a + hp;
										:} |
									Char_NO_QUOT_STAR:a HASH_FIXED:hf
										{:
											RESULT = a + hf;
										:} |
									Char_NO_QUOT_STAR:a HASH_IMPLIED:hi
										{:
											RESULT = a + hi;
										:} |
									Char_NO_QUOT_STAR:a HASH_REQUIRED:hr
										{:
											RESULT = a + hr;
										:} |
									Char_NO_QUOT_STAR:a CDATA:cdata
										{:
											RESULT = a + cdata;
										:} |
									Char_NO_QUOT_STAR:a SYSTEM:system
										{:
											RESULT = a + system;
										:} |
									Char_NO_QUOT_STAR:a PUBLIC:pub
										{:
											RESULT = a + pub;
										:} |
									Char_NO_QUOT_STAR:a NDATA_SURROUNDED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_QUOT_STAR:a NOTATION:n
										{:
											RESULT = a + n;
										:} |
									Char_NO_QUOT_STAR:a EMPTY:e
										{:
											RESULT = a + e;
										:} |
									Char_NO_QUOT_STAR:a ANY:any
										{:
											RESULT = a + any;
										:} |
									Char_NO_QUOT_STAR:a ID:id
										{:
											RESULT = a + id;
										:} |
									Char_NO_QUOT_STAR:a IDREF:idref
										{:
											RESULT = a + idref;
										:} |
									Char_NO_QUOT_STAR:a IDREFS:idrefs
										{:
											RESULT = a + idrefs;
										:} |
									Char_NO_QUOT_STAR:a ENTITY:entity
										{:
											RESULT = a + entity;
										:} |
									Char_NO_QUOT_STAR:a ENTITIES:entities
										{:
											RESULT = a + entities;
										:} |
									Char_NO_QUOT_STAR:a NMTOKEN:nmtoken
										{:
											RESULT = a + nmtoken;
										:} |
									Char_NO_QUOT_STAR:a NMTOKENS:nmtokens
										{:
											RESULT = a + nmtokens;
										:} |
									Char_NO_QUOT_STAR:a COMMA_SURROUNDED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_QUOT_STAR:a COMMA_PRECEDED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_QUOT_STAR:a COMMA_FOLLOWED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_QUOT_STAR:a PIPE_SURROUNDED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_QUOT_STAR:a PIPE_PRECEDED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_QUOT_STAR:a PIPE_FOLLOWED_BY_S:b
										{:
											RESULT = a + b;
										:};
// Char - "'"
Char_NO_APOS					::= CHAR:value
										{:
											RESULT = value;
										:} |
									AMP:value
										{:
											RESULT = value;
										:} |
									AT:value
										{:
											RESULT = value;
										:} |
									BACKTICK:value
										{:
											RESULT = value;
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH:value
										{:
											RESULT = value;
										:} |
									CARAT:value
										{:
											RESULT = value;
										:} |
									COLON:value
										{:
											RESULT = value;
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA:value
										{:
											RESULT = value;
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR:value
										{:
											RESULT = value;
										:} |
									DOT:value
										{:
											RESULT = value;
										:} |
									EQUALS:value
										{:
											RESULT = value;
										:} |
									EXCLAM:value
										{:
											RESULT = value;
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT:value
										{:
											RESULT = value;
										:} |
									HASH:value
										{:
											RESULT = value;
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE:value
										{:
											RESULT = value;
										:} |
									LPAREN:value
										{:
											RESULT = value;
										:} |
									LSQUARE:value
										{:
											RESULT = value;
										:} |
									LT:value
										{:
											RESULT = value;
										:} |
									MINUS:value
										{:
											RESULT = value;
										:} |
									PERCENT:value
										{:
											RESULT = value;
										:} |
									PLUS:value
										{:
											RESULT = value;
										:} |
									QMARK:value
										{:
											RESULT = value;
										:} |
									QUOT:value
										{:
											RESULT = value;
										:} |
									RBRACE:value
										{:
											RESULT = value;
										:} |
									RPAREN:value
										{:
											RESULT = value;
										:} |
									RSQUARE:value
										{:
											RESULT = value;
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI:value
										{:
											RESULT = value;
										:} |
									SLASH:value
										{:
											RESULT = value;
										:} |
									STAR:value
										{:
											RESULT = value;
										:} |
									TILDE:value
										{:
											RESULT = value;
										:} |
									UNDERSCORE:value
										{:
											RESULT = value;
										:};
// Char_NO_APOS*
Char_NO_APOS_STAR				::=	/* ε */
										{:
											RESULT = "";
										:} |
									Char_NO_APOS_STAR:a Char_NO_APOS:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a HASH_PCDATA:hash_pcdata
										{:
											RESULT = a + hash_pcdata;
										:} |
									Char_NO_APOS_STAR:a HASH_FIXED:hash_fixed
										{:
											RESULT = a + hash_fixed;
										:} |
									Char_NO_APOS_STAR:a HASH_IMPLIED:hash_implied
										{:
											RESULT = a + hash_implied;
										:} |
									Char_NO_APOS_STAR:a HASH_REQUIRED:hash_required
										{:
											RESULT = a + hash_required;
										:} |
									Char_NO_APOS_STAR:a CDATA:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a SYSTEM:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a PUBLIC:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a NDATA_SURROUNDED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a NOTATION:notation
										{:
											RESULT = a + notation;
										:} |
									Char_NO_APOS_STAR:a EMPTY:empty
										{:
											RESULT = a + empty;
										:} |
									Char_NO_APOS_STAR:a ANY:any
										{:
											RESULT = a + any;
										:} |
									Char_NO_APOS_STAR:a ID:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a IDREF:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a IDREFS:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a ENTITY:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a ENTITIES:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a NMTOKEN:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a NMTOKENS:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a COMMA_SURROUNDED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a COMMA_PRECEDED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a COMMA_FOLLOWED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a PIPE_SURROUNDED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a PIPE_PRECEDED_BY_S:b
										{:
											RESULT = a + b;
										:} |
									Char_NO_APOS_STAR:a PIPE_FOLLOWED_BY_S:b
										{:
											RESULT = a + b;
										:};
// Page 22
children						::= choice:c
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(c);
											RESULT.setMinMaxOccurs(1, 1);
										:} |
									choice:c QMARK
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(c);
											RESULT.setMinMaxOccurs(0, 1);
										:} |
									choice:c STAR
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(c);
											RESULT.setMinMaxOccurs(0, Constants.INFINITY);
										:} |
									choice:c PLUS
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(c);
											RESULT.setMinMaxOccurs(1, Constants.INFINITY);
										:} |
									seq:s
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(s);
											RESULT.setMinMaxOccurs(1, 1);
										:} |
									seq:s QMARK
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(s);
											RESULT.setMinMaxOccurs(0, 1);
										:} |
									seq:s STAR
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(s);
											RESULT.setMinMaxOccurs(0, Constants.INFINITY);
										:} |
									seq:s PLUS
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(s);
											RESULT.setMinMaxOccurs(1, Constants.INFINITY);
										:};
// Page 22
choice							::= LPAREN_FOLLOWED_BY_OPT_S cp:a PIPE_SURROUNDED_WITH_OPT_S cp:b RPAREN_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLAlternative();
											RESULT.addObject(a);
											RESULT.addObject(b);
										:} |
									LPAREN_FOLLOWED_BY_OPT_S cp:a PIPE_SURROUNDED_WITH_OPT_S cp:b choice_cpLIST:c RPAREN_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLAlternative();
											RESULT.addObject(a);
											RESULT.addObject(b);
											RESULT.append(c);
										:};
// (S? '|' S? cp)+
choice_cpLIST					::= PIPE_SURROUNDED_WITH_OPT_S cp:cp
										{:
											RESULT = new XMLAlternative();
											RESULT.addObject(cp);
										:} |
									choice_cpLIST:cpList PIPE_SURROUNDED_WITH_OPT_S cp:cp
										{:
											RESULT = cpList;
											RESULT.addObject(cp);
										:};
// S? ',' S?
COMMA_SURROUNDED_BY_OPT_S		::= COMMA:value
										{:
											RESULT = value;
										:} |
									COMMA_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:};
// Page 21
contentspec						::= EMPTY
										{:
											RESULT = new XMLElementContentModel(XMLElementContentType.EMPTY);
										:} |
									ANY
										{:
											RESULT = new XMLElementContentModel(XMLElementContentType.ANY);
										:} |
									Mixed:mixed
										{:
											RESULT = new XMLElementContentModel(mixed);
										:} |
									children:sequence
										{:
											RESULT = new XMLElementContentModel(sequence);
										:};
// Page 22
cp								::= Name:name
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(new XMLElementReference(name));
											RESULT.setMinMaxOccurs(1, 1);
										:} |
									Name:name QMARK
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(new XMLElementReference(name));
											RESULT.setMinMaxOccurs(0, 1);
										:} |
									Name:name STAR
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(new XMLElementReference(name));
											RESULT.setMinMaxOccurs(0, Constants.INFINITY);
										:} |
									Name:name PLUS
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(new XMLElementReference(name));
											RESULT.setMinMaxOccurs(1, Constants.INFINITY);
										:} |
									choice:c
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(c);
											RESULT.setMinMaxOccurs(1, 1);
										:} |
									choice:c QMARK
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(c);
											RESULT.setMinMaxOccurs(0, 1);
										:} |
									choice:c STAR
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(c);
											RESULT.setMinMaxOccurs(0, Constants.INFINITY);
										:} |
									choice:c PLUS
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(c);
											RESULT.setMinMaxOccurs(1, Constants.INFINITY);
										:} |
									seq:s
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(s);
											RESULT.setMinMaxOccurs(1, 1);
										:} |
									seq:s QMARK
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(s);
											RESULT.setMinMaxOccurs(0, 1);
										:} |
									seq:s STAR
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(s);
											RESULT.setMinMaxOccurs(0, Constants.INFINITY);
										:} |
									seq:s PLUS
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(s);
											RESULT.setMinMaxOccurs(1, Constants.INFINITY);
										:};
// Page 13
DeclSep							::= s;
// Page 28
DefaultDecl						::= HASH_REQUIRED
										{:
											RESULT = XMLAttributeDefaultType.REQUIRED();
										:} |
									HASH_IMPLIED
										{:
											RESULT = XMLAttributeDefaultType.IMPLIED();
										:} |
									HASH_FIXED s AttValue:value
										{:
											RESULT = XMLAttributeDefaultType.FIXED(value);
										:} |
									AttValue:value
										{:
											RESULT = XMLAttributeDefaultType.ATTVALUE(value);
										:};
// Page 21
elementdecl						::= ELEMENT_HEAD s Name:name s contentspec:contents GT_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLElement(name, contents);
											Log.debug("Parsed an element: " + RESULT);
										:};
// Page 35
EntityDecl						::= GEDecl:gedecl
										{:
											RESULT = gedecl;
											Log.debug("Parsed an entity: " + RESULT);
										:};
// Page 33
EntityRef						::= AMP Name:name SEMI
										{:
											RESULT = name;
										:};
// Page 9
EntityValue						::= QUOT EntityValue_QUOT_STRING:value QUOT
										{:
											RESULT = value;
										:} |
									APOS EntityValue_APOS_STRING:value APOS
										{:
											RESULT = value;
										:};
// A string made up of the characters allowed between quote marks in an EntityValue production
EntityValue_QUOT_STRING			::= /* ε */
										{:
											RESULT = "";
										:} |
									EntityValue_QUOT_STRING:a EntityValue_QUOT_STRING_CHAR:b
										{:
											RESULT = a + b;
										:} |
									EntityValue_QUOT_STRING:a Reference:b
										{:
											RESULT = a + b;
										:};
// The characters allowed between quote marks in an EntityValue production
EntityValue_QUOT_STRING_CHAR	::= CHAR:value
										{:
											RESULT = value;
										:} |
									APOS:value
										{:
											RESULT = value;
										:} |
									AT:value
										{:
											RESULT = value;
										:} |
									BACKTICK:value
										{:
											RESULT = value;
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH:value
										{:
											RESULT = value;
										:} |
									CARAT:value
										{:
											RESULT = value;
										:} |
									COLON:value
										{:
											RESULT = value;
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA:value
										{:
											RESULT = value;
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR:value
										{:
											RESULT = value;
										:} |
									DOT:value
										{:
											RESULT = value;
										:} |
									EQUALS:value
										{:
											RESULT = value;
										:} |
									EXCLAM:value
										{:
											RESULT = value;
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT:value
										{:
											RESULT = value;
										:} |
									HASH:value
										{:
											RESULT = value;
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE:value
										{:
											RESULT = value;
										:} |
									LPAREN:value
										{:
											RESULT = value;
										:} |
									LSQUARE:value
										{:
											RESULT = value;
										:} |
									LT:value
										{:
											RESULT = value;
										:} |
									MINUS:value
										{:
											RESULT = value;
										:} |
									PLUS:value
										{:
											RESULT = value;
										:} |
									QMARK:value
										{:
											RESULT = value;
										:} |
									RBRACE:value
										{:
											RESULT = value;
										:} |
									RPAREN:value
										{:
											RESULT = value;
										:} |
									RSQUARE:value
										{:
											RESULT = value;
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI:value
										{:
											RESULT = value;
										:} |
									SLASH:value
										{:
											RESULT = value;
										:} |
									STAR:value
										{:
											RESULT = value;
										:} |
									TILDE:value
										{:
											RESULT = value;
										:} |
									UNDERSCORE:value
										{:
											RESULT = value;
										:} |
									HASH_PCDATA:value
										{:
											RESULT = value;
										:} |
									HASH_FIXED:value
										{:
											RESULT = value;
										:} |
									HASH_IMPLIED:value
										{:
											RESULT = value;
										:} |
									HASH_REQUIRED:value
										{:
											RESULT = value;
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NDATA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:} |
									COMMA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:};
// A string made up of the characters allowed between apostrophes in an EntityValue production
EntityValue_APOS_STRING			::= /* ε */
										{:
											RESULT = "";
										:} |
									EntityValue_APOS_STRING:a EntityValue_APOS_STRING_CHAR:b
										{:
											RESULT = a + b;
										:} |
									EntityValue_APOS_STRING:a Reference:b
										{:
											RESULT = a + b;
										:};
// The characters allowed between apostrophes in an EntityValue production
EntityValue_APOS_STRING_CHAR	::= CHAR:value
										{:
											RESULT = value;
										:} |
									AT:value
										{:
											RESULT = value;
										:} |
									BACKTICK:value
										{:
											RESULT = value;
										:} |
									BASECHAR:value
										{:
											RESULT = value;
										:} |
									BSLASH:value
										{:
											RESULT = value;
										:} |
									CARAT:value
										{:
											RESULT = value;
										:} |
									COLON:value
										{:
											RESULT = value;
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									COMMA:value
										{:
											RESULT = value;
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOLLAR:value
										{:
											RESULT = value;
										:} |
									DOT:value
										{:
											RESULT = value;
										:} |
									EQUALS:value
										{:
											RESULT = value;
										:} |
									EXCLAM:value
										{:
											RESULT = value;
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									GT:value
										{:
											RESULT = value;
										:} |
									HASH:value
										{:
											RESULT = value;
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									LBRACE:value
										{:
											RESULT = value;
										:} |
									LPAREN:value
										{:
											RESULT = value;
										:} |
									LSQUARE:value
										{:
											RESULT = value;
										:} |
									LT:value
										{:
											RESULT = value;
										:} |
									MINUS:value
										{:
											RESULT = value;
										:} |
									PLUS:value
										{:
											RESULT = value;
										:} |
									QMARK:value
										{:
											RESULT = value;
										:} |
									QUOT:value
										{:
											RESULT = value;
										:} |
									RBRACE:value
										{:
											RESULT = value;
										:} |
									RPAREN:value
										{:
											RESULT = value;
										:} |
									RSQUARE:value
										{:
											RESULT = value;
										:} |
									S:value
										{:
											RESULT = value;
										:} |
									SEMI:value
										{:
											RESULT = value;
										:} |
									SLASH:value
										{:
											RESULT = value;
										:} |
									STAR:value
										{:
											RESULT = value;
										:} |
									TILDE:value
										{:
											RESULT = value;
										:} |
									UNDERSCORE:value
										{:
											RESULT = value;
										:} |
									HASH_PCDATA:value
										{:
											RESULT = value;
										:} |
									HASH_FIXED:value
										{:
											RESULT = value;
										:} |
									HASH_IMPLIED:value
										{:
											RESULT = value;
										:} |
									HASH_REQUIRED:value
										{:
											RESULT = value;
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NDATA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:} |
									COMMA_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									COMMA_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:};
// Page 27
EnumeratedType					::= NotationType:nType
										{:
											RESULT = nType;
										:} |
									Enumeration:eType
										{:
											RESULT = eType;
										:};
// Page 27
Enumeration						::= LPAREN_FOLLOWED_BY_OPT_S Nmtoken:nmtoken RPAREN_PRECEDED_BY_OPT_S
										{:
											// All the values
											List<String> values = new ArrayList<String>();

											// This Enumeration has only one possible value
											values.add(nmtoken);

											RESULT = XMLAttributeContentType.ENUMERATION(values);
										:} |
									LPAREN_FOLLOWED_BY_OPT_S Nmtoken:nmtoken Enumeration_NmtokenLIST:nmtokens RPAREN_PRECEDED_BY_OPT_S
										{:
											// All the values
											List<String> values = new ArrayList<String>();

											// Add the first name to the vector
											values.add(nmtoken);

											// Add the rest of the names to the vector
											for (Object token : nmtokens) {
												values.add(token.toString());
											}

											RESULT = XMLAttributeContentType.ENUMERATION(values);
										:};
// (S? '|' S? Nmtoken)+
Enumeration_NmtokenLIST			::= PIPE_SURROUNDED_WITH_OPT_S Nmtoken:nmtoken
										{:
											List<String> value = new ArrayList<String>();
											value.add(nmtoken);
											RESULT = value;
										:} |
									Enumeration_NmtokenLIST:values PIPE_SURROUNDED_WITH_OPT_S Nmtoken:nmtoken
										{:
											List<String> newTokenList = new ArrayList<String>();

											for (Object token : values) {
												newTokenList.add(token.toString());
											}

											newTokenList.add(nmtoken);

											RESULT = newTokenList;
										:};
// Page 36
ExternalID						::= SYSTEM s SystemLiteral:uri
										{:
											RESULT = new XMLExternalIdentifier(null, uri);
										:} |
									PublicID:pubid s SystemLiteral:uri
										{:
											RESULT = new XMLExternalIdentifier(pubid, uri);
										:};
// Page 14
extSubset						::= extSubsetDecl:eSD
										{:
											List<XMLNamedObject<?>> newExtSubSet = new ArrayList<XMLNamedObject<?>>();

											// Ensure that there is an element
											// declaration for every attribute
											// list declaration.
											for (Object attlist : eSD) {
												if (attlist != null) {
													if (XMLAttributeList.class.isAssignableFrom(attlist.getClass())) {
														String attlistName = ((XMLAttributeList)attlist).getName();
														boolean foundAssociatedElement = false;
														for (Object element : eSD) {
															if (element != null) {
																if (XMLElement.class.isAssignableFrom(element.getClass())) {
																	String elementName = ((XMLElement)element).getName();
																	if (elementName.equals(attlistName)) {
																		foundAssociatedElement = true;
																		break;
																	}
																}
															}
														}
														if (!foundAssociatedElement) {
															throw new ParserException(
																Message.XMLDOCTYPE_ORPHAN_ATTLIST(attlistName)
															);
														}
													}
												}
											}

											// Now re-wrap and cast the markup declarations.
											for (Object markupDecl : eSD) {
												newExtSubSet.add((XMLNamedObject)markupDecl);
											}
											
											RESULT = new XMLDocumentType(newExtSubSet);
										:};
// Page 14
extSubsetDecl					::= /* ε */
										{:
											RESULT = new ArrayList<XMLNamedObject>();
										:} |
									markupDecl:a extSubsetDecl:b
										{:
											List<XMLNamedObject> newDecls = new ArrayList<XMLNamedObject>();
											newDecls.add(a);
											for (Object listMarkup : b) {
												newDecls.add((XMLNamedObject)listMarkup);
											}

											RESULT = newDecls;
										:} |
									DeclSep extSubsetDecl:eSD
										{:
											RESULT = eSD;
										:};
// Page 35
GEDecl							::=	ENTITY_HEAD s Name:name s EntityValue:value GT_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLEntity(name, value);
										:} |
									ENTITY_HEAD s Name:name s ExternalID:extId GT_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLEntity(name, extId);
										:} |
									ENTITY_HEAD s Name:name s ExternalID:extId NDataDecl:ndata GT_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLEntity(name, extId, ndata);
										:};
// S? '>'
GT_PRECEDED_BY_OPT_S			::= GT:gt
										{:
											RESULT = gt;
										:} |
									s:s GT:gt
										{:
											RESULT = s + gt;
										:};
// '(' S?
LPAREN_FOLLOWED_BY_OPT_S		::= LPAREN:lp
										{:
											RESULT = lp;
										:} |
									LPAREN:lp s:s
										{:
											RESULT = lp + s;
										:};
// Page 13
markupDecl						::= elementdecl:e
										{:
											RESULT = e;
										:} |
									AttlistDecl:a
										{:
											RESULT = a;
										:} |
									EntityDecl:e
										{:
											RESULT = e;
										:} |
									NotationDecl:n
										{:
											RESULT = n;
										:} |
									COMMENT
										{:
											/* Ignore this, it's a comment token */
											RESULT = null;
										:};
// Page 23
Mixed							::= LPAREN_FOLLOWED_BY_OPT_S HASH_PCDATA Mixed_NameLIST:mixed RPAREN_PRECEDED_BY_OPT_S STAR
										{:
											RESULT = new XMLMixedContent();
											RESULT.addObject(new XMLContent());
											RESULT.append(mixed);
										:} |
									LPAREN_FOLLOWED_BY_OPT_S HASH_PCDATA RPAREN_PRECEDED_BY_OPT_S STAR
										{:
											RESULT = new XMLMixedContent();
											RESULT.addObject(new XMLContent());
										:} |
									LPAREN_FOLLOWED_BY_OPT_S HASH_PCDATA RPAREN_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLMixedContent();
											RESULT.addObject(new XMLContent());
										:};
// (S? '|' S? Name)+
Mixed_NameLIST					::= PIPE_SURROUNDED_WITH_OPT_S Name:name
										{:
											RESULT = new XMLMixedContent();
											RESULT.addObject(new XMLElementReference(name));
										:} |
									Mixed_NameLIST:mixed PIPE_SURROUNDED_WITH_OPT_S Name:name
										{:
											RESULT = mixed;
											RESULT.addObject(new XMLElementReference(name));
										:};
// Page 8
Name							::= NameStartChar:a NameChar_STAR:b
										{:
											RESULT = a + b;
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREF:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:};
// Page 8
NameChar						::= NameStartChar:value
										{:
											RESULT = value;
										:} |
									DIGIT:value
										{:
											RESULT = value;
										:} |
									DOT:value
										{:
											RESULT = value;
										:} |
									MINUS:value
										{:
											RESULT = value;
										:} |
									COMBININGCHAR:value
										{:
											RESULT = value;
										:} |
									EXTENDER:value
										{:
											RESULT = value;
										:} |
									CDATA:value
										{:
											RESULT = value;
										:} |
									SYSTEM:value
										{:
											RESULT = value;
										:} |
									PUBLIC:value
										{:
											RESULT = value;
										:} |
									NOTATION:value
										{:
											RESULT = value;
										:} |
									EMPTY:value
										{:
											RESULT = value;
										:} |
									ANY:value
										{:
											RESULT = value;
										:} |
									ID:value
										{:
											RESULT = value;
										:} |
									IDREF:value
										{:
											RESULT = value;
										:} |
									IDREFS:value
										{:
											RESULT = value;
										:} |
									ENTITY:value
										{:
											RESULT = value;
										:} |
									ENTITIES:value
										{:
											RESULT = value;
										:} |
									NMTOKEN:value
										{:
											RESULT = value;
										:} |
									NMTOKENS:value
										{:
											RESULT = value;
										:};
// NameChar*
NameChar_STAR					::= /* ε */
										{:
											RESULT = "";
										:} |
									NameChar_STAR:a NameChar:b
										{:
											RESULT = a + b;
										:};
// Characters that may start a Name token
NameStartChar					::= BASECHAR:value
										{:
											RESULT = value;
										:} |
									IDEOGRAPHIC:value
										{:
											RESULT = value;
										:} |
									UNDERSCORE:value
										{:
											RESULT = value;
										:} |
									COLON:value
										{:
											RESULT = value;
										:};
// Page 36
NDataDecl						::=	NDATA_SURROUNDED_BY_S Name:name
										{:
											RESULT = name;
										:};
// Page 8
Nmtoken							::= NameChar_STAR:a NameChar:b
										{:
											RESULT = a + b;
										:};
// Page 44
NotationDecl					::= NOTATION_HEAD s Name:name s ExternalID:extID GT_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLNotation(name, extID);
											Log.debug("Parsed a notation: " + RESULT);
										:} |
									NOTATION_HEAD s Name:name s PublicID:pubID GT_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLNotation(name, new XMLExternalIdentifier(pubID, null));
											Log.debug("Parsed a notation: " + RESULT);
										:};
// Page 27
NotationType					::= NOTATION s LPAREN_FOLLOWED_BY_OPT_S Name:name RPAREN_PRECEDED_BY_OPT_S
										{:
											// All the values
											List<String> values = new ArrayList<String>();

											// This NotationType has only one possible value
											values.add(name);

											RESULT = XMLAttributeContentType.NOTATION(values);
										:} |
									NOTATION s LPAREN_FOLLOWED_BY_OPT_S Name:name NotationType_NameLIST:names RPAREN_PRECEDED_BY_OPT_S
										{:
											// All the values
											List<String> values = new ArrayList<String>();

											// Add the first name to the vector
											values.add(name);

											// Add the rest of the names to the vector
											for (Object listName : names) {
												values.add(listName.toString());
											}

											RESULT = XMLAttributeContentType.NOTATION(values);
										:};
// (S? '|' S? Name)+
NotationType_NameLIST			::= PIPE_SURROUNDED_WITH_OPT_S Name:name
										{:
											List<String> value = new ArrayList<String>();
											value.add(name);
											RESULT = value;
										:} |
									NotationType_NameLIST:values PIPE_SURROUNDED_WITH_OPT_S Name:name
										{:
											List<String> newValues = new ArrayList<String>();
											
											// Copy in the values
											for (Object newValue : values) {
												newValues.add(newValue.toString());
											}
											
											// Add the name on the end.
											newValues.add(name);

											RESULT = newValues;
										:};
// S? '|' S?
PIPE_SURROUNDED_WITH_OPT_S		::= PIPE:value
										{:
											RESULT = value;
										:} |
									PIPE_PRECEDED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_FOLLOWED_BY_S:value
										{:
											RESULT = value;
										:} |
									PIPE_SURROUNDED_BY_S:value
										{:
											RESULT = value;
										:};
// Page 9
PubidLiteral					::= QUOT Char_NO_QUOT_STAR:value QUOT
										{:
											RESULT = value;
										:} |
									APOS Char_NO_APOS_STAR:value APOS
										{:
											RESULT = value;
										:};
// Page 44
PublicID						::= PUBLIC s PubidLiteral:value
										{:
											RESULT = value;
										:};
// Page 33
Reference						::= EntityRef:entityRefName
										{:
											RESULT = entityRefName;
										:} |
									CHARREF:value
										{:
											RESULT = value;
										:};
// S? ')'
RPAREN_PRECEDED_BY_OPT_S		::= RPAREN:rp
										{:
											RESULT = rp;
										:} |
									s:s RPAREN:rp
										{:
											RESULT = s + rp;
										:};
// S+
s								::= S:value
										{:
											RESULT = value;
										:} |
									s:a S:b
										{:
											RESULT = a + b;
										:};
// Page 22
seq								::= LPAREN_FOLLOWED_BY_OPT_S cp:cp RPAREN_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(cp);
										:} |
									LPAREN_FOLLOWED_BY_OPT_S cp:cp seq_cpLIST:seq RPAREN_PRECEDED_BY_OPT_S
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(cp);
											RESULT.append(seq);
										:};
// (S? ',' S?)+
seq_cpLIST						::= COMMA_SURROUNDED_BY_OPT_S cp:cp
										{:
											RESULT = new XMLSequence();
											RESULT.addObject(cp);
										:} |
									seq_cpLIST:seq COMMA_SURROUNDED_BY_OPT_S cp:cp
										{:
											RESULT = seq;
											RESULT.addObject(cp);
										:};
// Page 25
StringType						::= CDATA
										{:
											RESULT = XMLAttributeContentType.CDATA();
										:};
// Page 9
SystemLiteral					::= QUOT Char_NO_QUOT_STAR:value QUOT
										{:
											RESULT = value;
										:} |
									APOS Char_NO_APOS_STAR:value APOS
										{:
											RESULT = value;
										:};
// Page 25
TokenizedType					::= ID
										{:
											RESULT = XMLAttributeContentType.ID();
										:} |
									IDREF
										{:
											RESULT = XMLAttributeContentType.IDREF();
										:} |
									IDREFS
										{:
											RESULT = XMLAttributeContentType.IDREFS();
										:} |
									ENTITY
										{:
											RESULT = XMLAttributeContentType.ENTITY();
										:} |
									ENTITIES
										{:
											RESULT = XMLAttributeContentType.ENTITIES();
										:} |
									NMTOKEN
										{:
											RESULT = XMLAttributeContentType.NMTOKEN();
										:} |
									NMTOKENS
										{:
											RESULT = XMLAttributeContentType.NMTOKENS();
										:};
