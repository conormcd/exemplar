// vim:filetype=java:ts=4
/*
	Copyright (c) 2006
	Conor McDermottroe.  All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:
	1. Redistributions of source code must retain the above copyright
	   notice, this list of conditions and the following disclaimer.
	2. Redistributions in binary form must reproduce the above copyright
	   notice, this list of conditions and the following disclaimer in the
	   documentation and/or other materials provided with the distribution.
	3. Neither the name of the author nor the names of any contributors to
	   the software may be used to endorse or promote products derived from
	   this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
	TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
	OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package doc.com.mcdermottroe.exemplar.manual;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.InvocationTargetException;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;

import com.mcdermottroe.exemplar.Constants;
import com.mcdermottroe.exemplar.Utils;
import com.mcdermottroe.exemplar.DBC;
import com.mcdermottroe.exemplar.ui.Message;
import com.mcdermottroe.exemplar.ui.MessageException;
import com.mcdermottroe.exemplar.ui.Options;
import com.mcdermottroe.exemplar.ui.cli.ExitStatus;

/** Creates the manual for Exemplar from the skeleton, human-readable(ish)
	DocBook sources. The majority of the content in the manual is generated
	from here. This class actually generates an XSLT stylesheet which
	transforms the non-generated sources into the final DocBook sources which
	are then transformed by yet more XSLT into the man(1) and XHTML formats.

	@author	Conor McDermottroe
	@since	0.1
*/
public class CreateManual {
	/** Prevent this class from being instantiated. */
	private CreateManual() {}

	/** Create the manual.

		@param args	It's a main(), here are the args.
	*/
	public static void main(String[] args) {
		String outputFile = args[0];
		String docbookDTD = args[1];
		try {
			// Make sure that the messages are loaded.
			Message.localise();

			// Start building the XSLT
			StringBuilder xslt = new StringBuilder();

			// Make the preamble for the stylesheet
			xslt.append("<?xml version=\"1.0\" ?>").append(Constants.EOL);
			xslt.append("<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">").append(Constants.EOL);
			xslt.append("\t<xsl:output method=\"xml\" doctype-public=\"-//OASIS//DTD DocBook XML V4.2//EN\" doctype-system=\"");
			xslt.append(docbookDTD);
			xslt.append("\" indent=\"yes\" />").append(Constants.EOL);

			// Add the rule for the various autogenerated elements
			xslt.append("\t<xsl:template match=\"cmdsynopsis|para\">").append(Constants.EOL);
			xslt.append("\t\t<xsl:choose>").append(Constants.EOL);

			xslt.append(cmdsynopsisXSLT());
			xslt.append(optionsdescriptionXSLT());
			xslt.append(exitcodesXSLT());
			xslt.append(messagesXSLT());

			xslt.append("\t\t\t<xsl:otherwise>").append(Constants.EOL);
			xslt.append("\t\t\t\t<xsl:copy>").append(Constants.EOL);
			xslt.append("\t\t\t\t\t<xsl:apply-templates select=\"@*|node()\" />").append(Constants.EOL);
			xslt.append("\t\t\t\t</xsl:copy>").append(Constants.EOL);
			xslt.append("\t\t\t</xsl:otherwise>").append(Constants.EOL);
			xslt.append("\t\t</xsl:choose>").append(Constants.EOL);
			xslt.append("\t</xsl:template>").append(Constants.EOL);

			// Add the default copy rule
			xslt.append("\t<xsl:template match=\"@*|node()\">").append(Constants.EOL);
			xslt.append("\t\t<xsl:copy>").append(Constants.EOL);
			xslt.append("\t\t\t<xsl:apply-templates select=\"@*|node()\" />").append(Constants.EOL);
			xslt.append("\t\t</xsl:copy>").append(Constants.EOL);
			xslt.append("\t</xsl:template>").append(Constants.EOL);

			// Finish off the stylesheet
			xslt.append("</xsl:stylesheet>").append(Constants.EOL);

			// Write out the stylesheet
			BufferedWriter output = null;
			try {
				output =	new BufferedWriter(
								new FileWriter(
									new File(outputFile)
								)
							);
				output.write(xslt.toString());
			} finally {
				if (output != null) {
					output.close();
				}
			}
		} catch (IOException e) {
			throw new CreateManualException(e);
		} catch (MessageException e) {
			throw new CreateManualException(e);
		}
	}

	/** Create the synopsis section of the manual.

		@return	A {@link String} containing XSLT to transform the element with
				the id &quot;cmdsynopsis&quot; into the DocBook XML form of the
				synopsis line in the manual.
	*/
	private static String cmdsynopsisXSLT() {
		StringBuilder ret = new StringBuilder();
		ret.append("\t\t\t<xsl:when test=\"@id='cmdsynopsis'\">").append(Constants.EOL);

		ret.append("\t\t\t\t<cmdsynopsis>").append(Constants.EOL);
		ret.append("\t\t\t\t\t<command>");
		ret.append(Constants.PROGRAM_NAME);
		ret.append("</command>");
		ret.append(Constants.EOL);
		for (Iterator optionNames = Options.optionNameIterator(); optionNames.hasNext(); ) {
			String optionName = (String)optionNames.next();
			if (Options.isMandatory(optionName)) {
				ret.append("\t\t\t\t\t<arg choice=\"plain\">");
			} else {
				ret.append("\t\t\t\t\t<arg choice=\"opt\">");
			}
			ret.append("<link linkend=\"option.");
			ret.append(optionName);
			ret.append("\">");
			ret.append(Constants.UI.CLI.OPTION_PREFIX);
			ret.append(optionName);
			ret.append("</link>");
			if (Options.isArgument(optionName)) {
				ret.append(" <replaceable>");
				ret.append(optionName.replaceAll("-", "_"));
				ret.append("</replaceable>");
			} else if (Options.isEnum(optionName)) {
				ret.append(" <group choice=\"req\">");
				Map<String, String> eo = new TreeMap<String, String>(
					Options.getEnumDescriptions(optionName)
				);
				Iterator it = eo.keySet().iterator();
				if (it.hasNext()) {
					ret.append("<option>");
					ret.append((String)it.next());
					ret.append("</option>");
					while (it.hasNext()) {
						ret.append("<option>,");
						ret.append((String)it.next());
						ret.append("</option>");
					}
				}
				ret.append("</group>");
			}
			ret.append("</arg>").append(Constants.EOL);
		}
		ret.append("\t\t\t\t</cmdsynopsis>").append(Constants.EOL);

		return ret.append("\t\t\t</xsl:when>").append(Constants.EOL).toString();
	}

	/** Create the detailed description of every option that the program
		accepts.

		@return	A {@link String} containing the XSLT to transform the element
				with the id &quot;optionsdescription&quot; into the detailed
				description of every option that the program accepts.
	*/
	private static String optionsdescriptionXSLT() {
		StringBuilder ret = new StringBuilder();
		ret.append("\t\t\t<xsl:when test=\"@id='optionsdescription'\">").append(Constants.EOL);
		for (Iterator it = Options.optionNameIterator(); it.hasNext(); ) {
			String optionName = (String)it.next();

			ret.append("\t\t\t\t<refsect2");
			ret.append(" id=\"option.");
			ret.append(optionName);
			ret.append("\" xreflabel=\"");
			ret.append(Constants.UI.CLI.OPTION_PREFIX);
			ret.append(optionName);
			ret.append("\">");
			ret.append(Constants.EOL);
			ret.append("\t\t\t\t\t<title>");
			ret.append(Constants.UI.CLI.OPTION_PREFIX).append(optionName);
			ret.append("</title>").append(Constants.EOL);
			ret.append("\t\t\t\t\t<para>");
			ret.append(Options.getDescription(optionName));
			ret.append("</para>").append(Constants.EOL);
			if (Options.isEnum(optionName)) {
				Map<String,String> enumOptions = new TreeMap<String,String>(
					Options.getEnumDescriptions(optionName)
				);

				ret.append("\t\t\t\t\t<para>").append(Constants.EOL);
				ret.append("\t\t\t\t\t\t<variablelist>").append(Constants.EOL);
				ret.append("\t\t\t\t\t\t\t<title>");
				ret.append(Message.OPTION_ENUM_ARGS_HEADER);
				ret.append("</title>").append(Constants.EOL);
				for (String enumValue : enumOptions.keySet()) {
					ret.append("\t\t\t\t\t\t\t<varlistentry>").append(Constants.EOL);
					ret.append("\t\t\t\t\t\t\t\t<term>");
					ret.append(enumValue);
					ret.append("</term>").append(Constants.EOL);
					ret.append("\t\t\t\t\t\t\t\t<listitem>").append(Constants.EOL);
					ret.append("\t\t\t\t\t\t\t\t\t<para>");
					ret.append(Utils.escapeToXMLCharRefs(enumOptions.get(enumValue)));
					ret.append("</para>").append(Constants.EOL);
					ret.append("</listitem>").append(Constants.EOL);
					ret.append("\t\t\t\t\t\t\t</varlistentry>").append(Constants.EOL);
				}
				ret.append("\t\t\t\t\t\t</variablelist>").append(Constants.EOL);
				ret.append("\t\t\t\t\t</para>").append(Constants.EOL);
			}
			if (Options.isMandatory(optionName)) {
				ret.append("\t\t\t\t\t<para>");
				ret.append(Message.OPTION_IS_MANDATORY);
				ret.append("</para>").append(Constants.EOL);
			}
			String defaultValue = Options.describeDefault(optionName);
			if (defaultValue != null && !(Options.isSwitch(optionName))) {
				ret.append("\t\t\t\t\t<para>");
				ret.append(Message.OPTION_DEFAULT(defaultValue));
				ret.append("</para>").append(Constants.EOL);
			}
			ret.append("\t\t\t\t</refsect2>").append(Constants.EOL);
		}
		return ret.append("\t\t\t</xsl:when>").append(Constants.EOL).toString();
	}

	/** Describe all of the exit codes used by the program.

		@return	A {@link String} containing the XSLT to transform the element
				with the id &quot;exitcodes&quot; into the description of the
				exit codes used by the program.
	*/
	private static String exitcodesXSLT() {
		StringBuilder ret = new StringBuilder();
		ret.append("\t\t\t<xsl:when test=\"@id='exitcodes'\">").append(Constants.EOL);

		for (Iterator it = ExitStatus.iterator(); it.hasNext(); ) {
			String exitMnemonic = (String)it.next();

			ret.append("\t\t\t\t<refsect2>").append(Constants.EOL);
			ret.append("\t\t\t\t\t<title>");
			ret.append(ExitStatus.getExitCode(exitMnemonic)).append(": ");
			ret.append(exitMnemonic);
			ret.append("</title>").append(Constants.EOL);
			ret.append("\t\t\t\t\t<para>");
			ret.append(ExitStatus.getDescription(exitMnemonic));
			ret.append("</para>").append(Constants.EOL);
			ret.append("\t\t\t\t</refsect2>").append(Constants.EOL);
		}

		return ret.append("\t\t\t</xsl:when>").append(Constants.EOL).toString();
	}

	/** Describe all of the messages that can be output by the program.

		@return	A {@link String} containing the XSLT to transform the element
				with the id &quot;messages&quot; into the description of the
				messages that.
	*/
	private static String messagesXSLT() {
		StringBuilder ret = new StringBuilder();
		ret.append("\t\t\t<xsl:when test=\"@id='messages'\">").append(Constants.EOL);

		ret.append("\t\t\t\t<para>");
		ret.append("The following is a list of all possible messages that <command>");
		ret.append(Constants.PROGRAM_NAME);
		ret.append("</command> can produce. For each entry there is a symbolic name which corresponds to the variable in the Message class which holds this diagnostic message. The text portion after the symbolic name is the diagnostic message currently asssociated with the symbolic name. These messages may vary with different environmental settings (locales for example).").append(Constants.EOL);
		ret.append("\t\t\t\t</para>").append(Constants.EOL);

		try {
			Message.localise();

			Map<String,Object> messages = new TreeMap<String,Object>();

			// Get all of the static field messages
			// (they're the non-formatted ones)
			for (Field field : Message.class.getFields()) {
				try {
					messages.put(field.getName(), field.get(null));
				} catch (IllegalAccessException e) {
					DBC.IGNORED_EXCEPTION(e);
				}
			}

			// Find the message methods and call them
			// with dummy parameters to get the message
			// that appears when you call it.
			for (Method method : Message.class.getDeclaredMethods()) {
				// Must return String
				if (!String.class.equals(method.getReturnType())) {
					continue;
				}

				// Must be public static
				int mods = method.getModifiers();
				if (!Modifier.isPublic(mods) || !Modifier.isStatic(mods)) {
					continue;
				}

				// Generate a dummy parameter list
				Class[] paramTypes = method.getParameterTypes();
				Object[] params = new Object[paramTypes.length];
				for (int j = 0; j < paramTypes.length; j++) {
					if (String.class.equals(paramTypes[j])) {
						params[j] = "%s";
					} else if (double.class.equals(paramTypes[j])) {
						params[j] = 12345.6789;
					} else if (int.class.equals(paramTypes[j])) {
						params[j] = 123456789;
					} else {
						throw new CreateManualException("Unknown type " + paramTypes[j] + " for method parameter.");
					}
				}

				// Now call the method and get the message.
				String message;
				try {
					message = (String)method.invoke(null, params);
				} catch (IllegalAccessException e) {
					throw new CreateManualException(e);
				} catch (InvocationTargetException e) {
					throw new CreateManualException(e);
				}
				if (message == null) {
					continue;
				}

				// Replace the dummy numeric types with
				// their string parameter variables.
				message = message.replaceAll("1.?2.?3.?4.?5.?6.?7.?8.?9", "%d");

				// Now add the message name and value to the
				// list of known messages.
				messages.put(method.getName(), message);
			}

			for (String messageName : messages.keySet()) {
				String messageText = (String)messages.get(messageName);

				ret.append("\t\t\t\t<refsect2>").append(Constants.EOL);
				ret.append("\t\t\t\t\t<title>").append(messageName).append("</title>").append(Constants.EOL);
				ret.append("\t\t\t\t\t<para>");
				ret.append(escapeBasicXMLStuff(messageText));
				ret.append("</para>").append(Constants.EOL);
				ret.append("\t\t\t\t</refsect2>").append(Constants.EOL);
			}
		} catch (MessageException e) {
			ret.append("<para>An exception was thrown when trying to generate the documentation: ");
			ret.append(e.toString());
			ret.append("</para>");
		}

		return ret.append("\t\t\t</xsl:when>").append(Constants.EOL).toString();
	}

	/** Escape characters that could cause trouble in XML, the characters
		escaped are ampersand, less-than and greater-than characters.

		@param	unescaped	The {@link String} to be escaped.
		@return				The {@link String} <code>unescaped</code> with all
							ampersand, less-than and greater-than characters
							escaped to their XML entity forms.
	*/
	private static String escapeBasicXMLStuff(String unescaped) {
		String ret = unescaped.replaceAll("&", "&amp;");
		ret = ret.replaceAll("<", "&lt;");
		ret = ret.replaceAll(">", "&gt;");
		return ret;
	}

	/** The "error handling" in this mini-program is done by throwing one of
		these.

		@author	Conor McDermottroe
		@since	0.1
	*/
	private static class CreateManualException
	extends RuntimeException
	{
		/** Create an exception with a {@link String} describing the problem.

			@param	message	The message for the exception.
        */
		private CreateManualException(String message) {
			super(message);
		}

		/** Create an exception from the {@link Throwable} that caused the
			problem.

			@param	t	The {@link Throwable} that caused this {@link Exception}
		*/
		private CreateManualException(Throwable t) {
			super(t);
		}
	}
}
